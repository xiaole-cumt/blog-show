<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="小乐的日记本">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="小乐的日记本">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="小乐">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>小乐的日记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小乐的日记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/14/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88graspsamplenet%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/14/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88graspsamplenet%EF%BC%89/" class="post-title-link" itemprop="url">end to end源码解析（graspsamplenet）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-14 16:25:36" itemprop="dateCreated datePublished" datetime="2025-04-14T16:25:36+08:00">2025-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 17:36:33" itemprop="dateModified" datetime="2025-04-15T17:36:33+08:00">2025-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end源码解析（graspsamplenet）抓取点采样网络</h1>
<h2 id="PosePredictBatch">PosePredictBatch</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PosePredictBatch</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim=<span class="number">256</span>, point_num=<span class="number">50</span>, bn=<span class="literal">False</span>, use_tanh=<span class="literal">True</span>, feat_aggregator=<span class="string">&quot;avg&quot;</span></span>):</span><br><span class="line">        <span class="comment"># 初始化神经网络模块</span></span><br><span class="line">        <span class="built_in">super</span>(PosePredictBatch, <span class="variable language_">self</span>).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证特征聚合器类型是否有效</span></span><br><span class="line">        <span class="keyword">assert</span> feat_aggregator <span class="keyword">in</span> [<span class="string">&quot;max&quot;</span>, <span class="string">&quot;avg&quot;</span>, <span class="string">&quot;w_avg&quot;</span>], <span class="string">f&quot;feat_aggregator unknown: <span class="subst">&#123;feat_aggregator&#125;</span>&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.input_dim = input_dim  <span class="comment"># 输入特征维度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据聚合方式选择不同的聚合层</span></span><br><span class="line">        <span class="keyword">if</span> feat_aggregator == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">            <span class="comment"># 最大池化聚合器 [B x C x M x K] -&gt; [B x C x M x 1]</span></span><br><span class="line">            <span class="variable language_">self</span>.feat_aggregator = nn.MaxPool2d((<span class="number">1</span>, point_num), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">elif</span> feat_aggregator == <span class="string">&quot;avg&quot;</span>:</span><br><span class="line">            <span class="comment"># 平均池化聚合器</span></span><br><span class="line">            <span class="variable language_">self</span>.feat_aggregator = nn.AvgPool2d((<span class="number">1</span>, point_num), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 可学习的加权平均聚合器(使用1x1卷积实现)</span></span><br><span class="line">            <span class="variable language_">self</span>.feat_aggregator = p_utils.Conv2d(input_dim, input_dim, kernel_size=(<span class="number">1</span>, point_num), padding=<span class="number">0</span>, bn=bn)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 共享的第一层卷积，用于角度和第二接触点预测</span></span><br><span class="line">        <span class="variable language_">self</span>.conv1 = p_utils.Conv1d(input_dim, input_dim, <span class="number">1</span>, bn=bn)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二接触点预测网络(输出3D坐标)</span></span><br><span class="line">        <span class="variable language_">self</span>.second_contact_predictor = nn.Sequential(</span><br><span class="line">            p_utils.Conv1d(input_dim, <span class="number">256</span>, <span class="number">1</span>, bn=bn),  <span class="comment"># 特征变换层</span></span><br><span class="line">            p_utils.Conv1d(<span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, bn=bn, activation=<span class="literal">None</span>)  <span class="comment"># 输出层(无激活)</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 抓取角度预测网络(输出1个角度值)</span></span><br><span class="line">        <span class="variable language_">self</span>.angle_predictor = nn.Sequential(</span><br><span class="line">            p_utils.Conv1d(input_dim, <span class="number">256</span>, <span class="number">1</span>, bn=bn),  <span class="comment"># 特征变换层</span></span><br><span class="line">            p_utils.Conv1d(<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>, bn=bn, activation=<span class="literal">None</span>)  <span class="comment"># 输出层(无激活)</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据参数选择tanh激活或恒等映射</span></span><br><span class="line">        <span class="variable language_">self</span>.activation = nn.Tanh() <span class="keyword">if</span> use_tanh <span class="keyword">else</span> Identity()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, gather_feat</span>):</span><br><span class="line">        <span class="comment"># 输入特征维度转换 [B x M x K x C] -&gt; [B x C x M x K]</span></span><br><span class="line">        feat = <span class="variable language_">self</span>.feat_aggregator(gather_feat.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)).squeeze(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 通过共享卷积层</span></span><br><span class="line">        feat = <span class="variable language_">self</span>.conv1(feat)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分别预测第二接触点和角度</span></span><br><span class="line">        second_contact = <span class="variable language_">self</span>.second_contact_predictor(feat)</span><br><span class="line">        angle = <span class="variable language_">self</span>.angle_predictor(feat)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 应用激活函数</span></span><br><span class="line">        second_contact = <span class="variable language_">self</span>.activation(second_contact)</span><br><span class="line">        angle = <span class="variable language_">self</span>.activation(angle)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调整输出维度 [B x C x M] -&gt; [B x M x C]</span></span><br><span class="line">        <span class="keyword">return</span> second_contact.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>), angle.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_prediction_loss</span>(<span class="params">self, predicted, truth, angle_contribution=<span class="number">1.0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算预测损失(中心点距离 + 角度差异)</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            predicted: 预测的抓取姿态 [B x M x 7] (contact1, contact2, angle)</span></span><br><span class="line"><span class="string">            truth: 真实抓取姿态 [B x G x 7] </span></span><br><span class="line"><span class="string">            angle_contribution: 角度损失的权重系数</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            center_loss: 中心点位置误差</span></span><br><span class="line"><span class="string">            quaternion_loss: 四元数角度误差</span></span><br><span class="line"><span class="string">            loss: 总加权损失</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 交换真实抓取的两个接触点并拼接(增加匹配可能性)</span></span><br><span class="line">        swapped_truth = torch.cat([truth[:, :, <span class="number">3</span>:<span class="number">6</span>], truth[:, :, :<span class="number">3</span>], truth[:, :, -<span class="number">1</span>].unsqueeze(-<span class="number">1</span>)], dim=-<span class="number">1</span>)</span><br><span class="line">        new_truth = torch.cat([truth, swapped_truth], dim=<span class="number">1</span>)  <span class="comment"># [bs, 2G, 7]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算预测接触点与所有真实接触点的距离矩阵</span></span><br><span class="line">        all_contacts = new_truth[:, :, :<span class="number">3</span>]  <span class="comment"># 提取所有接触点坐标</span></span><br><span class="line">        predicted_contacts = predicted[:, :, :<span class="number">3</span>]</span><br><span class="line">        pred_truth_dist = torch.cdist(predicted_contacts, all_contacts)  <span class="comment"># [B, M, 2G]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找到每个预测抓取对应的最近真实抓取索引</span></span><br><span class="line">        _, min_dist_idxs = torch.<span class="built_in">min</span>(pred_truth_dist, dim=-<span class="number">1</span>)  <span class="comment"># [B, M]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 根据索引收集对应的真实抓取参数</span></span><br><span class="line">        per_sampled_points_truth = gather_by_idxs(new_truth, min_dist_idxs.long())  <span class="comment"># [B, M, 7]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将抓取表示转换为(中心点+四元数)形式</span></span><br><span class="line">        rep_predicted = reparametrize_grasps(predicted)  <span class="comment"># 预测抓取重参数化</span></span><br><span class="line">        rep_truth = reparametrize_grasps(per_sampled_points_truth)  <span class="comment"># 真实抓取重参数化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算中心点损失(L2距离)</span></span><br><span class="line">        predicted_centers = rep_predicted[:, :, :<span class="number">3</span>].squeeze(<span class="number">0</span>).contiguous()  <span class="comment"># [M, 3]</span></span><br><span class="line">        truth_centers = rep_truth[:, :, :<span class="number">3</span>].squeeze(<span class="number">0</span>).contiguous()  <span class="comment"># [M, 3]</span></span><br><span class="line">        center_loss = nn.functional.pairwise_distance(predicted_centers, truth_centers, p=<span class="number">2</span>).mean()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算四元数角度差异</span></span><br><span class="line">        eps = <span class="number">1e-5</span>  <span class="comment"># 数值稳定项</span></span><br><span class="line">        predicted_quaternions = rep_predicted[:, :, <span class="number">3</span>:<span class="number">7</span>].squeeze(<span class="number">0</span>)  <span class="comment"># [M, 4]</span></span><br><span class="line">        truth_quaternions = rep_truth[:, :, <span class="number">3</span>:<span class="number">7</span>].squeeze(<span class="number">0</span>)  <span class="comment"># [M, 4]</span></span><br><span class="line">        <span class="comment"># 计算四元数点积(衡量相似度)</span></span><br><span class="line">        scalar_product = torch.diagonal(torch.<span class="built_in">abs</span>(torch.matmul(predicted_quaternions, truth_quaternions.t())))  <span class="comment"># [M]</span></span><br><span class="line">        <span class="comment"># 通过反余弦计算角度差异(弧度)</span></span><br><span class="line">        quaternion_dist = torch.acos(torch.clamp(scalar_product, <span class="built_in">max</span>=<span class="number">1</span> - eps))</span><br><span class="line">        quaternion_loss = torch.mean(quaternion_dist)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 组合加权损失</span></span><br><span class="line">        loss = center_loss + angle_contribution * quaternion_loss</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> center_loss, quaternion_loss, loss</span><br></pre></td></tr></table></figure>
<h2 id="ContactAngleFeat">ContactAngleFeat</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接触点和角度特征提取模块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContactAngleFeat</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_dim=<span class="number">4</span>, out_dim=<span class="number">128</span>, bn=<span class="literal">False</span>, depth=<span class="number">2</span></span>):</span><br><span class="line">        <span class="comment"># 参数验证：depth只能是2或3</span></span><br><span class="line">        <span class="keyword">assert</span> depth <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>], <span class="string">&quot;the depth of this module could either be 2 or 3&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(ContactAngleFeat, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化参数</span></span><br><span class="line">        <span class="variable language_">self</span>.in_dim = in_dim    <span class="comment"># 输入特征维度(默认4: 3坐标+1角度)</span></span><br><span class="line">        <span class="variable language_">self</span>.out_dim = out_dim  <span class="comment"># 输出特征维度(默认128)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建特征提取网络</span></span><br><span class="line">        <span class="keyword">if</span> depth == <span class="number">3</span>:  <span class="comment"># 3层网络结构</span></span><br><span class="line">            <span class="variable language_">self</span>.layers = nn.Sequential(</span><br><span class="line">                p_utils.Conv1d(in_dim, <span class="number">64</span>, <span class="number">1</span>, bn=bn),    <span class="comment"># 第一层: 4-&gt;64维</span></span><br><span class="line">                p_utils.Conv1d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">1</span>, bn=bn),       <span class="comment"># 第二层: 64-&gt;128维</span></span><br><span class="line">                p_utils.Conv1d(<span class="number">128</span>, out_dim, bn=bn)      <span class="comment"># 第三层: 128-&gt;128维</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 2层网络结构(默认)</span></span><br><span class="line">            <span class="variable language_">self</span>.layers = nn.Sequential(</span><br><span class="line">                p_utils.Conv1d(in_dim, <span class="number">64</span>, <span class="number">1</span>, bn=bn),    <span class="comment"># 第一层: 4-&gt;64维</span></span><br><span class="line">                p_utils.Conv1d(<span class="number">64</span>, out_dim, bn=bn)       <span class="comment"># 第二层: 64-&gt;128维</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x: torch.Tensor</span>):</span><br><span class="line">        <span class="comment"># 输入维度调整: 确保输入是[B x 4 x M]格式</span></span><br><span class="line">        <span class="keyword">if</span> x.shape[<span class="number">1</span>] != <span class="variable language_">self</span>.in_dim:</span><br><span class="line">            x = x.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 如果不是[B x 4 x M]则转置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 输入维度验证</span></span><br><span class="line">        <span class="keyword">assert</span> x.shape[<span class="number">1</span>] == <span class="variable language_">self</span>.in_dim, <span class="string">&quot;Input tensor must be in shape [B x 4 x M]&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 特征提取</span></span><br><span class="line">        feat = <span class="variable language_">self</span>.layers(x)  <span class="comment"># 通过多层卷积网络</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 输出维度调整: 返回[B x M x C]格式</span></span><br><span class="line">        <span class="keyword">return</span> feat.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="GraspClassifier">GraspClassifier</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraspClassifier</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim=<span class="number">256</span>, point_num=<span class="number">50</span>, bn=<span class="literal">False</span>, feat_aggregator=<span class="string">&quot;avg&quot;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GraspClassifier, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.input_dim = input_dim  <span class="comment"># 输入特征维度，默认256</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 特征聚合器选择：最大池化、平均池化或可学习的加权平均</span></span><br><span class="line">        <span class="keyword">if</span> feat_aggregator == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.feat_aggregator = nn.MaxPool2d((<span class="number">1</span>, point_num), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">elif</span> feat_aggregator == <span class="string">&quot;avg&quot;</span>:</span><br><span class="line">            <span class="variable language_">self</span>.feat_aggregator = nn.AvgPool2d((<span class="number">1</span>, point_num), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">elif</span> feat_aggregator == <span class="string">&quot;w_avg&quot;</span>:</span><br><span class="line">            <span class="comment"># 使用卷积实现可学习的加权平均</span></span><br><span class="line">            <span class="variable language_">self</span>.feat_aggregator = p_utils.Conv2d(input_dim, input_dim, </span><br><span class="line">                                                 kernel_size=(<span class="number">1</span>, point_num), </span><br><span class="line">                                                 padding=<span class="number">0</span>, bn=bn)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Wrong feat_aggregator: <span class="subst">&#123;feat_aggregator&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主网络结构</span></span><br><span class="line">        <span class="variable language_">self</span>.conv1 = p_utils.Conv1d(input_dim, <span class="number">512</span>, <span class="number">1</span>, bn=bn)  <span class="comment"># 第一层卷积</span></span><br><span class="line">        <span class="variable language_">self</span>.score = nn.Sequential(  <span class="comment"># 评分网络</span></span><br><span class="line">            p_utils.Conv1d(<span class="number">512</span>, <span class="number">256</span>, <span class="number">1</span>, bn=bn),  <span class="comment"># 第二层卷积</span></span><br><span class="line">            p_utils.Conv1d(<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>, bn=bn, activation=<span class="literal">None</span>),  <span class="comment"># 输出层</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.sigmoid = nn.Sigmoid()  <span class="comment"># 将输出转换为概率</span></span><br><span class="line">        <span class="variable language_">self</span>.loss_criterion = nn.BCELoss()  <span class="comment"># 二分类交叉熵损失</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, gather_feat</span>):</span><br><span class="line">        <span class="comment"># 输入特征维度转换 [B x M x K x C] -&gt; [B x C x M x K]</span></span><br><span class="line">        feat = <span class="variable language_">self</span>.feat_aggregator(gather_feat.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)).squeeze(-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 特征处理</span></span><br><span class="line">        feat = <span class="variable language_">self</span>.conv1(feat)  <span class="comment"># 通过第一层卷积</span></span><br><span class="line">        score = <span class="variable language_">self</span>.sigmoid(<span class="variable language_">self</span>.score(feat))  <span class="comment"># 计算得分并转换为概率</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 输出维度转换 [B x 1 x M] -&gt; [B x M x 1]</span></span><br><span class="line">        <span class="keyword">return</span> score.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_classification_loss</span>(<span class="params">self, predicted, truth</span>):</span><br><span class="line">        <span class="comment"># 计算分类损失（二分类交叉熵）</span></span><br><span class="line">        loss = <span class="variable language_">self</span>.loss_criterion(predicted, truth)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure>
<h2 id="GraspSampleNet">GraspSampleNet</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraspSampleNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                 feat_extractor=<span class="string">&#x27;deco&#x27;</span>,  <span class="comment"># 特征提取器类型(&#x27;deco&#x27;或&#x27;pointnet2&#x27;)</span></span></span><br><span class="line"><span class="params">                 sampled_grasps=<span class="number">400</span>,      <span class="comment"># 要采样的抓取数量</span></span></span><br><span class="line"><span class="params">                 sample_group_size=<span class="number">10</span>,    <span class="comment"># 采样时的邻域点数量</span></span></span><br><span class="line"><span class="params">                 simp_loss=<span class="string">&#x27;chamfer&#x27;</span>,     <span class="comment"># 简化损失类型</span></span></span><br><span class="line"><span class="params">                 train_temperature=<span class="literal">True</span>,  <span class="comment"># 是否训练温度参数</span></span></span><br><span class="line"><span class="params">                 neigh_size=<span class="number">50</span>,           <span class="comment"># 邻域大小</span></span></span><br><span class="line"><span class="params">                 use_all_grasp_info=<span class="literal">False</span>, <span class="comment"># 是否使用完整的抓取信息</span></span></span><br><span class="line"><span class="params">                 use_contact_angle_feat=<span class="literal">True</span>, <span class="comment"># 是否使用接触点和角度特征</span></span></span><br><span class="line"><span class="params">                 angle_feat_depth=<span class="number">2</span>,       <span class="comment"># 角度特征提取器深度</span></span></span><br><span class="line"><span class="params">                 projected_feat_aggregation=<span class="string">&quot;w_avg&quot;</span>, <span class="comment"># 特征聚合方式</span></span></span><br><span class="line"><span class="params">                 bn=<span class="literal">False</span>,                <span class="comment"># 是否使用批归一化</span></span></span><br><span class="line"><span class="params">                 use_tanh=<span class="literal">True</span>,           <span class="comment"># 是否使用tanh激活</span></span></span><br><span class="line"><span class="params">                 deco_config_path=<span class="literal">None</span>,    <span class="comment"># DECO配置路径</span></span></span><br><span class="line"><span class="params">                 resume=<span class="literal">False</span>             <span class="comment"># 是否恢复训练(跳过预训练)</span></span></span><br><span class="line"><span class="params">                 </span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实验性功能检查</span></span><br><span class="line">        <span class="keyword">if</span> use_all_grasp_info:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">&#x27;use_all_grasp_info: experimental!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化网络参数</span></span><br><span class="line">        <span class="variable language_">self</span>.sampled_grasps = sampled_grasps</span><br><span class="line">        <span class="variable language_">self</span>.sample_group_size = sample_group_size</span><br><span class="line">        <span class="variable language_">self</span>.projected_feat_aggregation = projected_feat_aggregation</span><br><span class="line">        <span class="variable language_">self</span>.point_feat_dim = <span class="number">128</span>  <span class="comment"># 点特征维度(所有提取器必须一致)</span></span><br><span class="line">        <span class="variable language_">self</span>.neigh_size = neigh_size</span><br><span class="line">        <span class="variable language_">self</span>.use_all_grasp_info = use_all_grasp_info</span><br><span class="line">        <span class="variable language_">self</span>.use_contact_angle_feat = use_contact_angle_feat</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;特征提取器构建&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> feat_extractor == <span class="string">&#x27;pointnet2&#x27;</span>:</span><br><span class="line">            <span class="comment"># PointNet++特征提取器</span></span><br><span class="line">            <span class="variable language_">self</span>.encoder = build_pn2_encoder(input_channels=<span class="number">0</span>, bn=bn, return_global=<span class="literal">True</span>)</span><br><span class="line">            <span class="variable language_">self</span>.glob_feat_dim = (<span class="number">128</span> + <span class="number">1024</span>)  <span class="comment"># 最后SA层的特征 + 池化点特征</span></span><br><span class="line">        <span class="keyword">elif</span> feat_extractor == <span class="string">&#x27;deco&#x27;</span>:</span><br><span class="line">            <span class="comment"># DECO特征提取器</span></span><br><span class="line">            <span class="keyword">assert</span> deco_config_path <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> os.path.isfile(deco_config_path)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(deco_config_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> cf:</span><br><span class="line">                config = yaml.load(cf, Loader=yaml.FullLoader)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;DeCo encoder loaded config from <span class="subst">&#123;deco_config_path&#125;</span>: \n<span class="subst">&#123;config&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.glob_feat_dim = (config[<span class="string">&#x27;aggr_out_feat&#x27;</span>] + <span class="number">1024</span>)  <span class="comment"># 全局分支特征 + 池化点特征</span></span><br><span class="line">            <span class="variable language_">self</span>.encoder = build_deco_encoder(</span><br><span class="line">                bn=bn, config=config, return_global=<span class="literal">True</span>, no_pretext=resume)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unknown feat_extractor: <span class="subst">&#123;feat_extractor&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印网络配置信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;GraspSampleNet - feat_extractor: <span class="subst">&#123;feat_extractor&#125;</span>, &quot;</span></span><br><span class="line">              <span class="string">f&quot;point_feat_dim: <span class="subst">&#123;self.point_feat_dim&#125;</span>, &quot;</span></span><br><span class="line">              <span class="string">f&quot;glob_feat_dim: <span class="subst">&#123;self.glob_feat_dim&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;采样器构建&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.sampler = ContactSampleNet(</span><br><span class="line">            num_out_points=<span class="variable language_">self</span>.sampled_grasps,</span><br><span class="line">            bottleneck_size=<span class="variable language_">self</span>.glob_feat_dim,</span><br><span class="line">            is_temperature_trainable=train_temperature,</span><br><span class="line">            group_size=sample_group_size,</span><br><span class="line">            bn=bn,</span><br><span class="line">            simp_loss=simp_loss,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;抓取预测器构建&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.grasp_predictor = PosePredictBatch(</span><br><span class="line">            input_dim=<span class="variable language_">self</span>.point_feat_dim,</span><br><span class="line">            point_num=<span class="variable language_">self</span>.neigh_size,</span><br><span class="line">            bn=bn,</span><br><span class="line">            feat_aggregator=projected_feat_aggregation,</span><br><span class="line">            use_tanh=use_tanh</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;抓取分类器构建&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 确定输入维度(是否包含第一个接触点)</span></span><br><span class="line">        in_dim = <span class="number">7</span> <span class="keyword">if</span> <span class="variable language_">self</span>.use_all_grasp_info <span class="keyword">else</span> <span class="number">4</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.use_contact_angle_feat:</span><br><span class="line">            <span class="comment"># 使用接触点和角度特征提取器</span></span><br><span class="line">            <span class="variable language_">self</span>.contact_angle_feat_extractor = ContactAngleFeat(</span><br><span class="line">                in_dim=in_dim, out_dim=<span class="variable language_">self</span>.point_feat_dim, bn=bn, depth=angle_feat_depth)</span><br><span class="line">            grasp_classifier_input_dim = <span class="variable language_">self</span>.point_feat_dim</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 直接使用坐标和角度</span></span><br><span class="line">            <span class="variable language_">self</span>.contact_angle_feat_extractor = Identity()</span><br><span class="line">            grasp_classifier_input_dim = <span class="variable language_">self</span>.point_feat_dim + in_dim</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建最终的抓取分类器</span></span><br><span class="line">        <span class="variable language_">self</span>.grasp_classifier = GraspClassifier(</span><br><span class="line">            input_dim=grasp_classifier_input_dim,</span><br><span class="line">            point_num=<span class="variable language_">self</span>.neigh_size,</span><br><span class="line">            bn=bn,</span><br><span class="line">            feat_aggregator=projected_feat_aggregation</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_neigh_features</span>(<span class="params">self, x, y, point_feat, k, metric=<span class="string">&#x27;euclidean&#x27;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算邻域特征</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            x: 参考点云 [B x N x 3]</span></span><br><span class="line"><span class="string">            y: 需要提取特征的点云 [B x M x 3]</span></span><br><span class="line"><span class="string">            point_feat: 参考点云的特征 [B x C x N]</span></span><br><span class="line"><span class="string">            k: 邻域大小</span></span><br><span class="line"><span class="string">            metric: 距离度量(&#x27;euclidean&#x27;或&#x27;feature&#x27;)</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            邻域特征 [B x M x K x C]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> metric <span class="keyword">in</span> [<span class="string">&#x27;euclidean&#x27;</span>, <span class="string">&#x27;feature&#x27;</span>]</span><br><span class="line">        <span class="comment"># 调整特征维度</span></span><br><span class="line">        <span class="keyword">if</span> point_feat.shape[<span class="number">1</span>] != x.shape[<span class="number">1</span>]:</span><br><span class="line">            point_feat = point_feat.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">assert</span> point_feat.shape[<span class="number">1</span>] == x.shape[<span class="number">1</span>], <span class="string">&quot;特征与点云尺寸不匹配&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算距离矩阵</span></span><br><span class="line">        <span class="keyword">if</span> metric == <span class="string">&#x27;euclidean&#x27;</span>:</span><br><span class="line">            distance_matrix = - torch.cdist(y, x)  <span class="comment"># [B x M x N]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取最近的k个点索引</span></span><br><span class="line">        closest_index = distance_matrix.topk(k, dim=<span class="number">2</span>)[<span class="number">1</span>]  <span class="comment"># [B x M x K]</span></span><br><span class="line">        closest_index = closest_index.squeeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 收集邻域特征</span></span><br><span class="line">        gathered_projected_feat = point_feat[:, closest_index]  <span class="comment"># [B x M x K x C]</span></span><br><span class="line">        <span class="keyword">return</span> gathered_projected_feat</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, pc, gt_grasps=<span class="literal">None</span>, gt_sampling=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            pc: 输入点云 [B x N x 3]</span></span><br><span class="line"><span class="string">            gt_grasps: 真实抓取 [B x G x 7] (接触点1+接触点2+角度)</span></span><br><span class="line"><span class="string">            gt_sampling: 采样真值 [B x S x 3]</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            (生成点, 采样点), 预测抓取, 抓取分数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;1. 特征提取&quot;&quot;&quot;</span></span><br><span class="line">        point_feat, global_feat = <span class="variable language_">self</span>.encoder(pc)  <span class="comment"># 点特征和全局特征</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;2. 采样接触点&quot;&quot;&quot;</span></span><br><span class="line">        first_generated, first_sampled = <span class="variable language_">self</span>.sampler(pc, global_feat)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;3. 生成采样点特征&quot;&quot;&quot;</span></span><br><span class="line">        first_contact_feat = <span class="variable language_">self</span>.compute_neigh_features(</span><br><span class="line">            pc, first_sampled, point_feat, <span class="variable language_">self</span>.neigh_size)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;4. 预测最终抓取&quot;&quot;&quot;</span></span><br><span class="line">        first_contact = first_sampled</span><br><span class="line">        second_contact, angle = <span class="variable language_">self</span>.grasp_predictor(first_contact_feat)</span><br><span class="line">        predicted_grasps = torch.cat((first_contact, second_contact, angle), dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;5. 训练时使用真实抓取&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.training:</span><br><span class="line">            <span class="keyword">assert</span> gt_grasps <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">            gt_first_contact = gt_grasps[:, :, <span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">            gt_second_contact = gt_grasps[:, :, <span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line">            gt_angle = gt_grasps[:, :, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">            first_contact_feat = <span class="variable language_">self</span>.compute_neigh_features(</span><br><span class="line">                pc, gt_first_contact, point_feat, <span class="variable language_">self</span>.neigh_size)</span><br><span class="line">            first_contact = gt_first_contact</span><br><span class="line">            second_contact = gt_second_contact</span><br><span class="line">            angle = gt_angle.unsqueeze(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;6. 准备分类特征&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.use_all_grasp_info:</span><br><span class="line">            to_expand = torch.cat((first_contact, second_contact, angle), dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            to_expand = torch.cat((second_contact, angle), dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        second_contact_angle_feat = <span class="variable language_">self</span>.contact_angle_feat_extractor(to_expand)</span><br><span class="line">        second_contact_angle_feat = second_contact_angle_feat.unsqueeze(<span class="number">2</span>).expand(-<span class="number">1</span>, -<span class="number">1</span>, <span class="variable language_">self</span>.neigh_size, -<span class="number">1</span>)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;7. 分类抓取&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.use_contact_angle_feat:</span><br><span class="line">            grasp_feat = first_contact_feat + second_contact_angle_feat</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            grasp_feat = torch.cat((first_contact_feat, second_contact_angle_feat), dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        grasp_scores = <span class="variable language_">self</span>.grasp_classifier(grasp_feat)  <span class="comment"># [B x M x 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (first_generated, first_sampled), predicted_grasps, grasp_scores</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/09/end%20to%20end%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/09/end%20to%20end%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">end to end附加</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-09 15:38:26" itemprop="dateCreated datePublished" datetime="2025-04-09T15:38:26+08:00">2025-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-15 17:35:54" itemprop="dateModified" datetime="2025-04-15T17:35:54+08:00">2025-04-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end附加</h1>
<p>github链接：<a target="_blank" rel="noopener" href="https://github.com/antoalli/L2G">https://github.com/antoalli/L2G</a></p>
<h2 id="文件结构">文件结构</h2>
<p>.npy文件是Numpy库专用的二进制文件，用来保存数组</p>
<p>.exr文件保存的是深度图像</p>
<p>.obj文件是3D模型</p>
<p>.mtl文件包含了与 3D 模型表面相关的信息，如颜色、光泽、纹理贴图等</p>
<p>.urdf文件描述的是机器人模型</p>
<p>.csv文件保存的是excel表格文件.保存分割文件</p>
<h2 id="额外工具代码模块">额外工具代码模块</h2>
<p>ChamferDistance：计算两个点云集之间的双向距离 ：从点云A到点云B的最小距离（ dist1 ），从点云B到点云A的最小距离（ dist2 ）<br>
$$<br>
D_{CD}(S_1, S_2) = \frac{1}{|S_1|}\sum_{x\in S_1}\min_{y\in S_2}||x-y||^2 + \frac{1}{|S_2|}\sum_{y\in S_2}\min_{x\in S_1}||y-x||^2<br>
$$<br>
pytorch_utils:神经网络组件和训练流程的封装</p>
<p>quaternion：实现一系列四元数的函数计算</p>
<p>hausdorff：计算从A到B的单向距离（即A中每个点到B的最近距离的最大值）</p>
<p>grasp_utils：</p>
<table>
<thead>
<tr>
<th>抓取方向计算</th>
<th>姿态表示转换</th>
<th>抓取参数化转换</th>
<th>性能评估</th>
</tr>
</thead>
<tbody>
<tr>
<td>getUniqueGripperX2() : 计算并标准化夹爪的X轴方向</td>
<td>matrix2quaternion2() : 将旋转矩阵转换为四元数表示</td>
<td>reparametrize_grasps() : 在两种抓取表示之间转换</td>
<td>cal_accuracy() : 计算抓取预测的准确率和召回率</td>
</tr>
<tr>
<td>getOrientation2() : 根据接触点和角度计算完整的抓取姿态(旋转矩阵)</td>
<td>get_7dof_poses() : 将接触点表示转换为7自由度位姿(中心点+四元数)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/03/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88soft_projection)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/03/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88soft_projection)/" class="post-title-link" itemprop="url">end to end源码解析（soft_projection)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-03 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-03T00:00:00+08:00">2025-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 11:10:36" itemprop="dateModified" datetime="2025-04-14T11:10:36+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end源码解析（soft_projection)温度控制下的投影</h1>
<h2 id="knn-point">knn_point</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knn_point</span>(<span class="params">group_size, point_cloud, query_cloud</span>):</span><br><span class="line">    <span class="comment"># 创建KNN对象，k表示要找的最近邻点数量</span></span><br><span class="line">    <span class="comment"># transpose_mode=False 表示输入数据格式为(B, N, C)</span></span><br><span class="line">    knn_obj = KNN(k=group_size, transpose_mode=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行KNN搜索</span></span><br><span class="line">    <span class="comment"># dist: 返回K个最近邻的距离，形状为(B, N, K)</span></span><br><span class="line">    <span class="comment"># idx: 返回K个最近邻的索引，形状为(B, N, K)</span></span><br><span class="line">    dist, idx = knn_obj(point_cloud, query_cloud)</span><br><span class="line">    <span class="keyword">return</span> dist, idx</span><br></pre></td></tr></table></figure>
<h2 id="SoftProjection">SoftProjection</h2>
<p><img src="https://raw.githubusercontent.com/xiaole-cumt/blog-img/main/20250403143613011.png" alt="20250403143613011"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        计算软最近邻点云，通过可学习的温度参数控制投影的软硬度</span></span><br><span class="line"><span class="string">          参数：</span></span><br><span class="line"><span class="string">            group_size：整数，最近邻域中的邻居数量。</span></span><br><span class="line"><span class="string">            initial_temperature：正实数，温度参数的初始化常量。</span></span><br><span class="line"><span class="string">            is_temperature_trainable：布尔值。</span></span><br><span class="line"><span class="string">          输入：</span></span><br><span class="line"><span class="string">            point_cloud：形状为 (batch_size， 3， num_orig_points) 的 `Tensor`，数据库点云。</span></span><br><span class="line"><span class="string">            query_cloud：形状为 (batch_size， 3， num_query_points) 的 `Tensor`，要投影或传播的查询项。</span></span><br><span class="line"><span class="string">            point_features [可选]：形状为 (batch_size， num_features， num_orig_points) 的 `Tensor`，要传播的特征。</span></span><br><span class="line"><span class="string">            action [可选]：&#x27;project&#x27;、&#x27;propagate&#x27; 或 &#x27;project_and_propagate&#x27;。</span></span><br><span class="line"><span class="string">          输出：</span></span><br><span class="line"><span class="string">            取决于 &#x27;action&#x27;：</span></span><br><span class="line"><span class="string">            propagated_features：形状为 (batch_size， num_features， num_query_points) 的 `Tensor`</span></span><br><span class="line"><span class="string">            projected_points：形状为 (batch_size， 3， num_query_points) 的 `Tensor`&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoftProjection</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            group_size,  <span class="comment"># 最近邻搜索的邻居数量</span></span></span><br><span class="line"><span class="params">            initial_temperature=<span class="number">1.0</span>,  <span class="comment"># 温度参数初始值，控制投影软硬度</span></span></span><br><span class="line"><span class="params">            is_temperature_trainable=<span class="literal">True</span>,  <span class="comment"># 温度参数是否可训练</span></span></span><br><span class="line"><span class="params">            min_sigma=<span class="number">1e-4</span>,  <span class="comment"># 温度参数的最小值，防止数值不稳定</span></span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;软最近邻点云计算模块&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>._group_size = group_size  <span class="comment"># 保存邻居数量</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.initial_temperature = initial_temperature</span><br><span class="line">        <span class="comment"># 创建可训练的温度参数</span></span><br><span class="line">        <span class="variable language_">self</span>._temperature = torch.nn.Parameter(</span><br><span class="line">            torch.tensor(</span><br><span class="line">                initial_temperature,</span><br><span class="line">                requires_grad=is_temperature_trainable,  <span class="comment"># 根据参数设置是否可训练</span></span><br><span class="line">                dtype=torch.float32,</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._min_sigma = torch.tensor(min_sigma, dtype=torch.float32)  <span class="comment"># 最小sigma值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, point_cloud, query_cloud, point_features=<span class="literal">None</span>, action=<span class="string">&quot;project&quot;</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;前向传播主函数&quot;&quot;&quot;</span></span><br><span class="line">        point_cloud = point_cloud.contiguous()  <span class="comment"># 确保内存连续</span></span><br><span class="line">        query_cloud = query_cloud.contiguous()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据action参数选择不同操作</span></span><br><span class="line">        <span class="keyword">if</span> action == <span class="string">&quot;project&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.project(point_cloud, query_cloud)  <span class="comment"># 仅投影</span></span><br><span class="line">        <span class="keyword">elif</span> action == <span class="string">&quot;propagate&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.propagate(point_cloud, point_features, query_cloud)  <span class="comment"># 仅特征传播</span></span><br><span class="line">        <span class="keyword">elif</span> action == <span class="string">&quot;project_and_propagate&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.project_and_propagate(point_cloud, point_features, query_cloud)  <span class="comment"># 两者都做</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;action参数必须是&#x27;project&#x27;、&#x27;propagate&#x27;或&#x27;project_and_propagate&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_group_points</span>(<span class="params">self, point_cloud, query_cloud, point_features=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;分组点云和特征&quot;&quot;&quot;</span></span><br><span class="line">        group_size = <span class="variable language_">self</span>._group_size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用KNN查找最近邻</span></span><br><span class="line">        dist, idx = knn_point(group_size, point_cloud, query_cloud)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调整索引格式为 Batch x QueryPoints x K</span></span><br><span class="line">        idx = idx.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>).<span class="built_in">type</span>(torch.int32)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 分组点坐标</span></span><br><span class="line">        grouped_points = group_point(point_cloud, idx.contiguous())  <span class="comment"># [B, 3, QueryPoints, K]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 分组特征（如果有）</span></span><br><span class="line">        grouped_features = <span class="literal">None</span> <span class="keyword">if</span> point_features <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> group_point(point_features, idx)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grouped_points, grouped_features</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_distances</span>(<span class="params">self, grouped_points, query_cloud</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算归一化距离&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 计算每个查询点与其邻居的差值</span></span><br><span class="line">        deltas = grouped_points - query_cloud.unsqueeze(-<span class="number">1</span>).expand_as(grouped_points)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算平方距离并除以温度参数</span></span><br><span class="line">        dist = torch.<span class="built_in">sum</span>(deltas ** <span class="number">2</span>, dim=_axis_to_dim(<span class="number">3</span>), keepdim=<span class="literal">True</span>) / <span class="variable language_">self</span>.sigma()</span><br><span class="line">        <span class="keyword">return</span> dist</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sigma</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取温度参数，确保不小于最小值&quot;&quot;&quot;</span></span><br><span class="line">        device = <span class="variable language_">self</span>._temperature.device</span><br><span class="line">        <span class="keyword">return</span> torch.<span class="built_in">max</span>(<span class="variable language_">self</span>._temperature ** <span class="number">2</span>, <span class="variable language_">self</span>._min_sigma.to(device))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_temperature</span>(<span class="params">self, epoch, tot_epochs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;温度退火更新&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._temperature.data = torch.tensor(</span><br><span class="line">            <span class="variable language_">self</span>.initial_temperature * math.exp(-epoch * <span class="number">10</span> / tot_epochs),</span><br><span class="line">            dtype=torch.float32</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">project_and_propagate</span>(<span class="params">self, point_cloud, point_features, query_cloud</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;联合投影和特征传播&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 分组点云和特征</span></span><br><span class="line">        grouped_points, grouped_features = <span class="variable language_">self</span>._group_points(point_cloud, query_cloud, point_features)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 计算距离</span></span><br><span class="line">        dist = <span class="variable language_">self</span>._get_distances(grouped_points, query_cloud)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 通过softmax计算权重</span></span><br><span class="line">        weights = torch.softmax(-dist, dim=_axis_to_dim(<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 加权平均计算投影点和传播特征</span></span><br><span class="line">        projected_points = torch.<span class="built_in">sum</span>(grouped_points * weights, dim=_axis_to_dim(<span class="number">2</span>))</span><br><span class="line">        propagated_features = torch.<span class="built_in">sum</span>(grouped_features * weights, dim=_axis_to_dim(<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (projected_points, propagated_features)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">propagate</span>(<span class="params">self, point_cloud, point_features, query_cloud</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;仅特征传播&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 分组点云和特征</span></span><br><span class="line">        grouped_points, grouped_features = <span class="variable language_">self</span>._group_points(point_cloud, query_cloud, point_features)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算距离</span></span><br><span class="line">        dist = <span class="variable language_">self</span>._get_distances(grouped_points, query_cloud)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算权重</span></span><br><span class="line">        weights = torch.softmax(-dist, dim=_axis_to_dim(<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加权平均传播特征</span></span><br><span class="line">        propagated_features = torch.<span class="built_in">sum</span>(grouped_features * weights, dim=_axis_to_dim(<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> propagated_features</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">project</span>(<span class="params">self, point_cloud, query_cloud, hard=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;仅点云投影&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 分组点云</span></span><br><span class="line">        grouped_points, _ = <span class="variable language_">self</span>._group_points(point_cloud, query_cloud)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算距离</span></span><br><span class="line">        dist = <span class="variable language_">self</span>._get_distances(grouped_points, query_cloud)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算权重</span></span><br><span class="line">        weights = torch.softmax(-dist, dim=_axis_to_dim(<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> hard:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError  <span class="comment"># 硬投影未实现</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 扩展权重以匹配坐标维度</span></span><br><span class="line">        weights = weights.repeat(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 加权平均计算投影点</span></span><br><span class="line">        projected_points = torch.<span class="built_in">sum</span>(grouped_points * weights, dim=_axis_to_dim(<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> projected_points</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/02/end-to-end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88sputils%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/02/end-to-end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88sputils%EF%BC%89/" class="post-title-link" itemprop="url">end to end源码解析（sputils)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-02 17:24:36" itemprop="dateCreated datePublished" datetime="2025-04-02T17:24:36+08:00">2025-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 14:24:36" itemprop="dateModified" datetime="2025-04-14T14:24:36+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end 源码解析（sputils)采样算法和参数</h1>
<h2 id="calc-distances">_calc_distances</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_calc_distances</span>(<span class="params">p0, points</span>):</span><br><span class="line">    <span class="keyword">return</span> ((p0 - points) ** <span class="number">2</span>).<span class="built_in">sum</span>(axis=<span class="number">1</span>)  <span class="comment"># 计算点 p0 与点集中各点的欧氏距离平方</span></span><br></pre></td></tr></table></figure>
<h2 id="fps-from-given-pc">_fps_from_given_pc</h2>
<p>给定点集到当前点集的最小距离中选择最小距离最远的点（当前点集中的），也就是到给定点集中最大最小距离的点，放入给定点集中再次最远点采样，选出第二大最小距离的点放入给定点集中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_fps_from_given_pc</span>(<span class="params">pts, k, given_pc</span>):</span><br><span class="line">    <span class="comment"># 初始化一个k×3的零矩阵，用于存储最终选取的点</span></span><br><span class="line">    farthest_pts = np.zeros((k, <span class="number">3</span>))</span><br><span class="line">    <span class="comment"># 计算给定点集given_pc中的点数(t = 点数×3维坐标 / 3)</span></span><br><span class="line">    t = np.size(given_pc) // <span class="number">3</span></span><br><span class="line">    <span class="comment"># 将给定的初始点集复制到结果矩阵的前t行</span></span><br><span class="line">    farthest_pts[<span class="number">0</span>:t] = given_pc</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算第一个给定点与所有点之间的距离</span></span><br><span class="line">    distances = _calc_distances(farthest_pts[<span class="number">0</span>], pts)</span><br><span class="line">    <span class="comment"># 对于剩下的给定点(从第2个到第t个)，更新最小距离</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, t):</span><br><span class="line">        distances = np.minimum(distances, _calc_distances(farthest_pts[i], pts))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从第t+1个点开始，进行FPS采样</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t, k):</span><br><span class="line">        <span class="comment"># 选择当前距离最远的点</span></span><br><span class="line">        farthest_pts[i] = pts[np.argmax(distances)]</span><br><span class="line">        <span class="comment"># 更新所有点到新选点的距离，并保持最小距离</span></span><br><span class="line">        distances = np.minimum(distances, _calc_distances(farthest_pts[i], pts))</span><br><span class="line">    <span class="comment"># 返回最终选取的k个点</span></span><br><span class="line">    <span class="keyword">return</span> farthest_pts</span><br></pre></td></tr></table></figure>
<h2 id="unique">_unique</h2>
<p>去除重复元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_unique</span>(<span class="params">arr</span>):</span><br><span class="line">    _, idx = np.unique(arr, return_index=<span class="literal">True</span>)  <span class="comment"># 获取唯一值和索引</span></span><br><span class="line">    <span class="keyword">return</span> arr[np.sort(idx)]  <span class="comment"># 返回排序后的唯一值</span></span><br></pre></td></tr></table></figure>
<h2 id="nn-matching">nn_matching</h2>
<p>进行点云的匹配和采样，共有 3 种模式：</p>
<table>
<thead>
<tr>
<th>FPS 模式（complete_fps = True）</th>
<th>先去除重复索引; 用最远点采样算法补充到 k 个点</th>
</tr>
</thead>
<tbody>
<tr>
<td>权重模式（counts 不为 None）</td>
<td>按照 counts 权重值降序排序选择点</td>
</tr>
<tr>
<td>直接模式</td>
<td>直接使用给定索引选择点</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nn_matching</span>(<span class="params">full_pc, idx, k, complete_fps=<span class="literal">True</span>, counts=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 获取输入点云的batch大小</span></span><br><span class="line">    batch_size = np.size(full_pc, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 初始化输出点云数组，形状为(batch_size, k, 3)</span></span><br><span class="line">    out_pc = np.zeros((full_pc.shape[<span class="number">0</span>], k, <span class="number">3</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历batch中的每个点云</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, batch_size):</span><br><span class="line">        <span class="comment"># 获取当前点云的索引</span></span><br><span class="line">        best_idx = idx[ii]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果启用完整FPS采样</span></span><br><span class="line">        <span class="keyword">if</span> complete_fps:</span><br><span class="line">            <span class="comment"># 对索引去重</span></span><br><span class="line">            best_idx = _unique(best_idx)</span><br><span class="line">            <span class="comment"># 使用FPS算法从给定点开始采样</span></span><br><span class="line">            out_pc[ii] = _fps_from_given_pc(full_pc[ii], k, full_pc[ii][best_idx])</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 如果有提供counts参数</span></span><br><span class="line">        <span class="keyword">elif</span> counts <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 按counts降序排列索引</span></span><br><span class="line">            best_idx = best_idx[np.argsort(-counts)]</span><br><span class="line">            <span class="comment"># 直接选取前k个点</span></span><br><span class="line">            out_pc[ii] = full_pc[ii][best_idx]</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 默认情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 直接使用提供的索引选取点</span></span><br><span class="line">            out_pc[ii] = full_pc[ii][best_idx]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回截取前k个点的结果</span></span><br><span class="line">    <span class="keyword">return</span> out_pc[:, <span class="number">0</span>:k, :]</span><br></pre></td></tr></table></figure>
<h2 id="get-parser">get_parser</h2>
<p>用于配置SampleNet点云采样模型的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_parser</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(<span class="string">&quot;SampleNet: Differentiable Point Cloud Sampling&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加各种参数选项</span></span><br><span class="line">    <span class="comment"># 训练相关参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--skip-projection&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;训练时不投影点&quot;</span>)</span><br><span class="line">    <span class="comment"># 点云规模参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;-in&quot;</span>, <span class="string">&quot;--num-in-points&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1024</span>, <span class="built_in">help</span>=<span class="string">&quot;输入点数&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-out&quot;</span>, <span class="string">&quot;--num-out-points&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">64</span>, <span class="built_in">help</span>=<span class="string">&quot;输出点数&quot;</span>)</span><br><span class="line">    <span class="comment"># 网络结构参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--bottleneck-size&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">128</span>, <span class="built_in">help</span>=<span class="string">&quot;瓶颈层大小&quot;</span>)</span><br><span class="line">    <span class="comment"># 损失函数权重参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--alpha&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.01</span>, <span class="built_in">help</span>=<span class="string">&quot;简化正则化权重&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--gamma&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">&quot;Lb常数正则化权重&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--delta&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0</span>, <span class="built_in">help</span>=<span class="string">&quot;Lb线性正则化权重&quot;</span>)</span><br><span class="line">    <span class="comment"># 投影相关参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;-gs&quot;</span>, <span class="string">&quot;--projection-group-size&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">8</span>, <span class="built_in">help</span>=<span class="string">&quot;软投影邻域大小&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--lmbda&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.01</span>, <span class="built_in">help</span>=<span class="string">&quot;投影正则化权重&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/02/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88utils%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/02/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88utils%EF%BC%89/" class="post-title-link" itemprop="url">end to end源码解析（utils）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-02T00:00:00+08:00">2025-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 14:28:46" itemprop="dateModified" datetime="2025-04-14T14:28:46+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end 源码解析（utils）一些工具函数</h1>
<h2 id="gather-by-idxs">gather_by_idxs</h2>
<p>详细看GPDNet中的index_points</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gather_by_idxs</span>(<span class="params">source, idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        source: input points data, [B, N, C]</span></span><br><span class="line"><span class="string">        idx: sample index data, [B, S]</span></span><br><span class="line"><span class="string">    Return:</span></span><br><span class="line"><span class="string">        new_points:, indexed points data, [B, S, C]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    device = source.device</span><br><span class="line">    B = source.shape[<span class="number">0</span>]</span><br><span class="line">    view_shape = <span class="built_in">list</span>(idx.shape)</span><br><span class="line">    view_shape[<span class="number">1</span>:] = [<span class="number">1</span>] * (<span class="built_in">len</span>(view_shape) - <span class="number">1</span>)</span><br><span class="line">    repeat_shape = <span class="built_in">list</span>(idx.shape)</span><br><span class="line">    repeat_shape[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    batch_indices = torch.arange(B, dtype=torch.long).to(device).view(view_shape).repeat(repeat_shape)</span><br><span class="line">    new_points = source[batch_indices, idx, :]</span><br><span class="line">    <span class="keyword">return</span> new_points</span><br></pre></td></tr></table></figure>
<h2 id="set-random-seed">set_random_seed</h2>
<p>同时设置多个库的随机种子，确保了在深度学习实验中的随机性是可控的，特别是在比较不同模型的性能时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_random_seed</span>(<span class="params">seed</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; set random seed &quot;&quot;&quot;</span></span><br><span class="line">    random.seed(seed)</span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    torch.cuda.manual_seed_all(seed)</span><br></pre></td></tr></table></figure>
<h2 id="str2bool">str2bool</h2>
<p>将字符串转为布尔型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">str2bool</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, <span class="built_in">bool</span>):</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    <span class="keyword">if</span> v.lower() <span class="keyword">in</span> (<span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> v.lower() <span class="keyword">in</span> (<span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;false&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> argparse.ArgumentTypeError(<span class="string">&#x27;Boolean value expected.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="AverageMeter">AverageMeter</h2>
<p>这个类用于计算和存储平均值，在深度学习训练过程中常用于跟踪指标（如损失值、准确率等）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AverageMeter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 计算并存储平均值和当前值 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, fmt=<span class="string">&#x27;:f&#x27;</span></span>):</span><br><span class="line">        <span class="comment"># 初始化时设置指标名称和显示格式</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 指标名称(如&#x27;Loss&#x27;, &#x27;Accuracy&#x27;)</span></span><br><span class="line">        <span class="variable language_">self</span>.fmt = fmt    <span class="comment"># 数值格式(默认浮点数&#x27;:f&#x27;)</span></span><br><span class="line">        <span class="variable language_">self</span>.reset()      <span class="comment"># 重置所有统计量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 重置所有统计计数器</span></span><br><span class="line">        <span class="variable language_">self</span>.val = <span class="number">0</span>    <span class="comment"># 当前值</span></span><br><span class="line">        <span class="variable language_">self</span>.avg = <span class="number">0</span>    <span class="comment"># 平均值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">sum</span> = <span class="number">0</span>    <span class="comment"># 总和</span></span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span>  <span class="comment"># 计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, val, n=<span class="number">1</span></span>):</span><br><span class="line">        <span class="comment"># 更新统计量</span></span><br><span class="line">        <span class="variable language_">self</span>.val = val          <span class="comment"># 记录最新值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">sum</span> += val * n     <span class="comment"># 累加值(考虑batch size)</span></span><br><span class="line">        <span class="variable language_">self</span>.count += n         <span class="comment"># 累加计数</span></span><br><span class="line">        <span class="variable language_">self</span>.avg = <span class="variable language_">self</span>.<span class="built_in">sum</span> / <span class="variable language_">self</span>.count  <span class="comment"># 计算新平均值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 格式化输出: 显示当前值和平均值</span></span><br><span class="line">        fmtstr = <span class="string">&#x27;&#123;name&#125; &#123;val&#x27;</span> + <span class="variable language_">self</span>.fmt + <span class="string">&#x27;&#125; (&#123;avg&#x27;</span> + <span class="variable language_">self</span>.fmt + <span class="string">&#x27;&#125;)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> fmtstr.<span class="built_in">format</span>(**<span class="variable language_">self</span>.__dict__)</span><br></pre></td></tr></table></figure>
<h2 id="check-dataparallel">check_dataparallel</h2>
<p>这个函数通常用于模型加载时，判断是否需要去除DataParallel添加的’module.'前缀。==单gpu训练不需要这段代码==，当模型在多GPU上训练时使用DataParallel包装，保存的模型参数会自动添加这个前缀。但在单GPU或CPU上加载时，需要去除这个前缀才能正确加载模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_dataparallel</span>(<span class="params">state_dict</span>):</span><br><span class="line">    res = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> k, _ <span class="keyword">in</span> state_dict.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>(k).startswith(<span class="string">&#x27;module&#x27;</span>):</span><br><span class="line">            res = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h2 id="sanitize-model-dict">sanitize_model_dict</h2>
<p>移除保存模型的多级前缀</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sanitize_model_dict</span>(<span class="params">state_dict, to_remove_str=<span class="string">&#x27;module&#x27;</span></span>):</span><br><span class="line">    new_state_dict = OrderedDict()</span><br><span class="line">    remove_len = <span class="built_in">len</span>(to_remove_str) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> state_dict.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>(k).startswith(to_remove_str):</span><br><span class="line">            name = k[remove_len:]</span><br><span class="line">            new_state_dict[name] = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_state_dict[k] = v</span><br><span class="line">    <span class="keyword">return</span> new_state_dict</span><br></pre></td></tr></table></figure>
<h2 id="count-params">count_params</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_params</span>(<span class="params">model</span>):</span><br><span class="line">    <span class="comment"># 计算模型总参数数量(包括可训练和不可训练参数)</span></span><br><span class="line">    tot_params = <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算可训练参数数量(requires_grad=True的参数)</span></span><br><span class="line">    trainable_params = <span class="built_in">sum</span>(p.numel() <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters() <span class="keyword">if</span> p.requires_grad)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打印参数统计结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Num params: <span class="subst">&#123;tot_params&#125;</span>, Trainable: <span class="subst">&#123;trainable_params&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回总参数数和可训练参数数</span></span><br><span class="line">    <span class="keyword">return</span> tot_params, trainable_params</span><br></pre></td></tr></table></figure>
<h2 id="plot-grad-flow">plot_grad_flow</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_grad_flow</span>(<span class="params">named_parameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可视化神经网络梯度流动情况</span></span><br><span class="line"><span class="string">    Credits to RoshanRane: https://discuss.pytorch.org/t/check-gradient-flow-in-network/15063/8</span></span><br><span class="line"><span class="string">    :param named_parameters:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ave_grads = []</span><br><span class="line">    layers = []</span><br><span class="line">    <span class="comment"># 遍历所有命名参数</span></span><br><span class="line">    <span class="keyword">for</span> n, p <span class="keyword">in</span> named_parameters:</span><br><span class="line">        <span class="comment"># 只处理需要梯度且不是偏置的参数</span></span><br><span class="line">        <span class="keyword">if</span> p.requires_grad <span class="keyword">and</span> (<span class="string">&quot;bias&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> n):</span><br><span class="line">            <span class="comment"># 检查梯度是否存在</span></span><br><span class="line">            <span class="keyword">if</span> p.grad <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                warnings.warn(<span class="string">f&#x27;Grad is none for layer <span class="subst">&#123;n&#125;</span>.&#x27;</span>, RuntimeWarning)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 记录层名(截取前15个字符)和平均梯度绝对值</span></span><br><span class="line">            layers.append(n[:<span class="number">15</span>])</span><br><span class="line">            ave_grads.append(p.grad.cpu().<span class="built_in">abs</span>().mean())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘制梯度曲线</span></span><br><span class="line">    plt.plot(ave_grads, alpha=<span class="number">0.3</span>, color=<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    <span class="comment"># 添加零基准线</span></span><br><span class="line">    plt.hlines(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(ave_grads)+<span class="number">1</span>, linewidth=<span class="number">1</span>, color=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">    <span class="comment"># 设置x轴刻度(使用层名)</span></span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ave_grads), <span class="number">1</span>), layers, rotation=<span class="string">&quot;vertical&quot;</span>)</span><br><span class="line">    <span class="comment"># 设置坐标轴范围</span></span><br><span class="line">    plt.xlim(xmin=<span class="number">0</span>, xmax=<span class="built_in">len</span>(ave_grads))</span><br><span class="line">    <span class="comment"># 添加标签</span></span><br><span class="line">    plt.xlabel(<span class="string">&quot;Layers&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;Average gradient&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Gradient flow&quot;</span>)</span><br><span class="line">    <span class="comment"># 添加网格并调整布局</span></span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回图形对象</span></span><br><span class="line">    <span class="keyword">return</span> plt.gcf()</span><br></pre></td></tr></table></figure>
<h2 id="IOStream">IOStream</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IOStream</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通用文本日志记录器</span></span><br><span class="line"><span class="string">    功能：同时输出到控制台(带颜色)和日志文件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, path</span>):</span><br><span class="line">        <span class="comment"># 以追加模式打开日志文件</span></span><br><span class="line">        <span class="variable language_">self</span>.f = <span class="built_in">open</span>(path, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="comment"># 定义颜色lambda函数</span></span><br><span class="line">        <span class="variable language_">self</span>.blue = <span class="keyword">lambda</span> x: <span class="string">&#x27;\033[94m&#x27;</span> + x + <span class="string">&#x27;\033[0m&#x27;</span>  <span class="comment"># 蓝色</span></span><br><span class="line">        <span class="variable language_">self</span>.red = <span class="keyword">lambda</span> x: <span class="string">&#x27;\033[31m&#x27;</span> + x + <span class="string">&#x27;\033[0m&#x27;</span>   <span class="comment"># 红色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cprint</span>(<span class="params">self, text, color=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        彩色打印并记录到文件</span></span><br><span class="line"><span class="string">        :param text: 要输出的文本</span></span><br><span class="line"><span class="string">        :param color: 颜色选项 (&#x27;b&#x27;/&#x27;blue&#x27; 或 &#x27;r&#x27;/&#x27;red&#x27;)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> color <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> (color == <span class="string">&#x27;b&#x27;</span> <span class="keyword">or</span> color == <span class="string">&#x27;blue&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="variable language_">self</span>.blue(text))  <span class="comment"># 蓝色输出</span></span><br><span class="line">        <span class="keyword">elif</span> color <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> (color == <span class="string">&#x27;r&#x27;</span> <span class="keyword">or</span> color == <span class="string">&#x27;red&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="variable language_">self</span>.red(text))   <span class="comment"># 红色输出</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(text)             <span class="comment"># 普通输出</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 同时写入文件(无颜色)</span></span><br><span class="line">        <span class="variable language_">self</span>.f.write(text + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.f.flush()  <span class="comment"># 立即刷新缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fprint</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        仅记录到文件(不打印到控制台)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.f.write(text + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.f.flush()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        关闭日志文件</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.f.close()</span><br></pre></td></tr></table></figure>
<h2 id="safe-make-dirs">safe_make_dirs</h2>
<p>安全创建目录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_make_dirs</span>(<span class="params">dirs</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(dirs, <span class="built_in">list</span>):</span><br><span class="line">        dirs = [dirs]</span><br><span class="line">    <span class="keyword">for</span> currdir <span class="keyword">in</span> dirs:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(currdir):<span class="comment">#如果不存在，判断为true，进入if语句</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Creating directory: <span class="subst">&#123;currdir&#125;</span>&quot;</span>)</span><br><span class="line">            os.makedirs(currdir)</span><br></pre></td></tr></table></figure>
<h2 id="打印信息设置">打印信息设置</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bcolors</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;ANSI 颜色代码定义&quot;&quot;&quot;</span></span><br><span class="line">    HEADER = <span class="string">&#x27;\033[95m&#x27;</span>    <span class="comment"># 紫色</span></span><br><span class="line">    OKBLUE = <span class="string">&#x27;\033[94m&#x27;</span>    <span class="comment"># 蓝色</span></span><br><span class="line">    OKCYAN = <span class="string">&#x27;\033[96m&#x27;</span>    <span class="comment"># 青色</span></span><br><span class="line">    OKGREEN = <span class="string">&#x27;\033[92m&#x27;</span>   <span class="comment"># 绿色</span></span><br><span class="line">    WARNING = <span class="string">&#x27;\033[93m&#x27;</span>   <span class="comment"># 黄色(警告)</span></span><br><span class="line">    FAIL = <span class="string">&#x27;\033[91m&#x27;</span>      <span class="comment"># 红色(错误)</span></span><br><span class="line">    ENDC = <span class="string">&#x27;\033[0m&#x27;</span>       <span class="comment"># 重置颜色</span></span><br><span class="line">    BOLD = <span class="string">&#x27;\033[1m&#x27;</span>       <span class="comment"># 加粗</span></span><br><span class="line">    UNDERLINE = <span class="string">&#x27;\033[4m&#x27;</span>  <span class="comment"># 下划线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_bold</span>(<span class="params">pstring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加粗打印文本&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(bcolors.BOLD + pstring + bcolors.ENDC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_warn</span>(<span class="params">pstring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;黄色警告打印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(bcolors.WARNING + pstring + bcolors.ENDC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_fail</span>(<span class="params">pstring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;红色错误打印&quot;&quot;&quot;</span> </span><br><span class="line">    <span class="built_in">print</span>(bcolors.FAIL + pstring + bcolors.ENDC)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_ok</span>(<span class="params">pstring</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;蓝色成功打印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(bcolors.OKBLUE + pstring + bcolors.ENDC)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/02/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88ContactSampleNet%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/02/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88ContactSampleNet%EF%BC%89/" class="post-title-link" itemprop="url">end to end源码解析（ContactSampleNet）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-02T00:00:00+08:00">2025-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 16:22:36" itemprop="dateModified" datetime="2025-04-14T16:22:36+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end源码解析（ContactSampleNet）接触点采样网络和损失</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function  <span class="comment"># 确保Python2/3兼容性</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 数值计算库</span></span><br><span class="line"><span class="keyword">import</span> torch  <span class="comment"># PyTorch深度学习框架</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn  <span class="comment"># PyTorch神经网络模块</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F  <span class="comment"># PyTorch函数操作</span></span><br><span class="line"><span class="keyword">from</span> knn_cuda <span class="keyword">import</span> KNN  <span class="comment"># CUDA加速的K近邻算法</span></span><br><span class="line"><span class="keyword">from</span> l2g_core.chamfer_distance.chamfer_distance <span class="keyword">import</span> ChamferDistance  <span class="comment"># Chamfer距离计算</span></span><br><span class="line"><span class="keyword">from</span> l2g_core.utils.identity <span class="keyword">import</span> Identity  <span class="comment"># 恒等映射</span></span><br><span class="line"><span class="keyword">from</span> l2g_core.utils.hausdorff <span class="keyword">import</span> directed_hausdorff  <span class="comment"># Hausdorff距离计算</span></span><br><span class="line"><span class="keyword">from</span> l2g_core.soft_projection <span class="keyword">import</span> SoftProjection  <span class="comment"># 软投影层</span></span><br><span class="line"><span class="keyword">from</span> l2g_core <span class="keyword">import</span> sputils  <span class="comment"># 采样工具</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> torch.cuda.is_available(), <span class="string">&quot;ContactSampleNet: CUDA is not available&quot;</span>  <span class="comment"># 检查CUDA可用性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContactSampleNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            num_out_points,  <span class="comment"># 输出点云数量</span></span></span><br><span class="line"><span class="params">            bottleneck_size,  <span class="comment"># 瓶颈层特征维度</span></span></span><br><span class="line"><span class="params">            group_size,  <span class="comment"># 投影组大小</span></span></span><br><span class="line"><span class="params">            initial_temperature=<span class="number">1.0</span>,  <span class="comment"># 初始温度参数</span></span></span><br><span class="line"><span class="params">            is_temperature_trainable=<span class="literal">True</span>,  <span class="comment"># 温度参数是否可训练</span></span></span><br><span class="line"><span class="params">            min_sigma=<span class="number">1e-2</span>,  <span class="comment"># 最小sigma值</span></span></span><br><span class="line"><span class="params">            input_shape=<span class="string">&quot;bnc&quot;</span>,  <span class="comment"># 输入形状格式</span></span></span><br><span class="line"><span class="params">            output_shape=<span class="string">&quot;bnc&quot;</span>,  <span class="comment"># 输出形状格式</span></span></span><br><span class="line"><span class="params">            bn=<span class="literal">True</span>,  <span class="comment"># 是否使用批归一化</span></span></span><br><span class="line"><span class="params">            simp_loss=<span class="string">&#x27;chamfer&#x27;</span>  <span class="comment"># 简化损失类型</span></span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()  <span class="comment"># 调用父类初始化</span></span><br><span class="line">        <span class="variable language_">self</span>.num_out_points = num_out_points</span><br><span class="line">        <span class="variable language_">self</span>.bn = bn</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="string">&quot;contactsamplenet&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义全连接层</span></span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(bottleneck_size, <span class="number">256</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc3 = nn.Linear(<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc4 = nn.Linear(<span class="number">256</span>, <span class="number">3</span> * num_out_points)  <span class="comment"># 输出3D坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义批归一化层或恒等映射</span></span><br><span class="line">        <span class="variable language_">self</span>.bn_fc1 = nn.BatchNorm1d(<span class="number">256</span>) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity()</span><br><span class="line">        <span class="variable language_">self</span>.bn_fc2 = nn.BatchNorm1d(<span class="number">256</span>) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity()</span><br><span class="line">        <span class="variable language_">self</span>.bn_fc3 = nn.BatchNorm1d(<span class="number">256</span>) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 投影和匹配相关参数</span></span><br><span class="line">        <span class="variable language_">self</span>.is_temperature_trainable = is_temperature_trainable</span><br><span class="line">        <span class="variable language_">self</span>.project = SoftProjection(  <span class="comment"># 软投影层</span></span><br><span class="line">            group_size, initial_temperature, is_temperature_trainable, min_sigma</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.simp_loss = simp_loss</span><br><span class="line">        <span class="variable language_">self</span>.input_shape = input_shape</span><br><span class="line">        <span class="variable language_">self</span>.output_shape = output_shape</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x: torch.Tensor, global_feat: torch.Tensor</span>):</span><br><span class="line">        <span class="comment"># 调整输入张量形状</span></span><br><span class="line">        <span class="keyword">if</span> x.shape[<span class="number">1</span>] != <span class="number">3</span>:</span><br><span class="line">            x = x.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 确保点云输入形状为B x 3 X N</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过全连接网络处理全局特征</span></span><br><span class="line">        y = global_feat</span><br><span class="line">        y = F.relu(<span class="variable language_">self</span>.bn_fc1(<span class="variable language_">self</span>.fc1(y)))  <span class="comment"># 第一层+BN+ReLU</span></span><br><span class="line">        y = F.relu(<span class="variable language_">self</span>.bn_fc2(<span class="variable language_">self</span>.fc2(y)))  <span class="comment"># 第二层+BN+ReLU</span></span><br><span class="line">        y = F.relu(<span class="variable language_">self</span>.bn_fc3(<span class="variable language_">self</span>.fc3(y)))  <span class="comment"># 第三层+BN+ReLU</span></span><br><span class="line">        y = <span class="variable language_">self</span>.fc4(y)  <span class="comment"># 输出层</span></span><br><span class="line">        y = y.view(-<span class="number">1</span>, <span class="number">3</span>, <span class="variable language_">self</span>.num_out_points)  <span class="comment"># 重塑为3D坐标</span></span><br><span class="line"></span><br><span class="line">        generated = y  <span class="comment"># 生成的点(不一定在物体表面)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在输入点云上进行投影</span></span><br><span class="line">        proj = <span class="variable language_">self</span>.project(point_cloud=x, query_cloud=y)  <span class="comment"># 投影点是物体表面点的加权组合</span></span><br><span class="line">        <span class="keyword">match</span> = <span class="literal">None</span>  <span class="comment"># 硬采样匹配点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 仅在推理时执行硬采样</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.training:</span><br><span class="line">            <span class="comment"># 获取最近邻索引</span></span><br><span class="line">            _, idx = KNN(<span class="number">1</span>, transpose_mode=<span class="literal">False</span>)(x.contiguous(), y.contiguous())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 转换为numpy数组(B x N x 3格式)</span></span><br><span class="line">            x = x.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line">            y = y.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>).cpu().detach().numpy()</span><br><span class="line">            idx = idx.cpu().detach().numpy()</span><br><span class="line">            idx = np.squeeze(idx)</span><br><span class="line">            idx, counts = np.unique(idx, return_counts=<span class="literal">True</span>)  <span class="comment"># 获取唯一索引和计数</span></span><br><span class="line">            idx = np.reshape(idx, (<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 执行最近邻匹配</span></span><br><span class="line">            z = sputils.nn_matching(x, idx, idx.shape[<span class="number">1</span>], complete_fps=<span class="literal">False</span>, counts=counts)</span><br><span class="line">            <span class="keyword">match</span> = torch.tensor(z, dtype=torch.float32).cuda()  <span class="comment"># 转回CUDA张量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调整输出形状</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.output_shape == <span class="string">&quot;bnc&quot;</span>:</span><br><span class="line">            generated = generated.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> proj <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                proj = proj.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.output_shape == <span class="string">&quot;bcn&quot;</span> <span class="keyword">and</span> <span class="keyword">match</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">match</span> = <span class="keyword">match</span>.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">match</span> = <span class="keyword">match</span>.contiguous()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保张量内存连续</span></span><br><span class="line">        generated = generated.contiguous()</span><br><span class="line">        <span class="keyword">if</span> proj <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            proj = proj.contiguous()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">match</span> = <span class="keyword">match</span>.contiguous()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据训练/推理模式选择输出</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.training:</span><br><span class="line">            sampled = proj  <span class="comment"># 训练时使用软投影</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sampled = <span class="keyword">match</span>  <span class="comment"># 推理时使用硬采样</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> generated, sampled  <span class="comment"># 返回生成点和采样点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, x</span>):</span><br><span class="line">        simp, proj, <span class="keyword">match</span>, feat = <span class="variable language_">self</span>.__call__(x)  <span class="comment"># 调用forward方法</span></span><br><span class="line">        <span class="keyword">return</span> proj  <span class="comment"># 返回投影点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_simplification_loss</span>(<span class="params">self, samp_pc, ref_pc, gamma=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算简化损失(Chamfer或Hausdorff)</span></span><br><span class="line"><span class="string">        @param ref_pc: 真实点云</span></span><br><span class="line"><span class="string">        @param samp_pc: 采样点云</span></span><br><span class="line"><span class="string">        @param gamma: Chamfer距离第二项的权重</span></span><br><span class="line"><span class="string">        @return: 选择的损失</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.simp_loss == <span class="string">&#x27;chamfer&#x27;</span>:</span><br><span class="line">            <span class="comment"># 调整形状</span></span><br><span class="line">            <span class="keyword">if</span> ref_pc.shape[<span class="number">2</span>] != <span class="number">3</span>:</span><br><span class="line">                ref_pc = ref_pc.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">                samp_pc = samp_pc.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">assert</span> ref_pc.shape[<span class="number">2</span>] == <span class="number">3</span> <span class="keyword">and</span> samp_pc.shape[<span class="number">2</span>] == <span class="number">3</span>, <span class="string">&quot;Chamfer输入形状必须为B X N X 3&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算Chamfer距离</span></span><br><span class="line">            cost_p1_p2, cost_p2_p1 = ChamferDistance()(samp_pc, ref_pc)</span><br><span class="line">            max_cost = torch.<span class="built_in">max</span>(cost_p1_p2, dim=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># 最远点距离</span></span><br><span class="line">            max_cost = torch.mean(max_cost)</span><br><span class="line">            cost_p1_p2 = torch.mean(cost_p1_p2)  <span class="comment"># 采样点到真实点的平均距离</span></span><br><span class="line">            cost_p2_p1 = torch.mean(cost_p2_p1)  <span class="comment"># 真实点到采样点的平均距离</span></span><br><span class="line">            loss = cost_p1_p2 + max_cost + gamma * cost_p2_p1  <span class="comment"># 组合损失</span></span><br><span class="line">            <span class="keyword">return</span> cost_p1_p2, max_cost, cost_p2_p1, loss</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 计算Hausdorff距离</span></span><br><span class="line">            <span class="keyword">if</span> ref_pc.shape[<span class="number">1</span>] != <span class="number">3</span>:</span><br><span class="line">                ref_pc = ref_pc.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">                samp_pc = samp_pc.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">assert</span> ref_pc.shape[-<span class="number">1</span>] == <span class="number">3</span> <span class="keyword">and</span> samp_pc.shape[-<span class="number">1</span>] == <span class="number">3</span>, <span class="string">&quot;Hausdorff输入形状必须为B X 3 X N&quot;</span></span><br><span class="line">            loss = directed_hausdorff(ref_pc, samp_pc)  <span class="comment"># 计算定向Hausdorff距离</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, loss  <span class="comment"># 返回占位值和损失</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_projection_loss</span>(<span class="params">self</span>):</span><br><span class="line">        sigma = <span class="variable language_">self</span>.project.sigma()  <span class="comment"># 获取投影层的sigma值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.training <span class="keyword">or</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_temperature_trainable:</span><br><span class="line">            <span class="keyword">return</span> torch.tensor(<span class="number">0</span>).to(sigma)  <span class="comment"># 非训练模式或温度不可训练时返回0</span></span><br><span class="line">        <span class="keyword">return</span> sigma  <span class="comment"># 返回sigma作为投影损失</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/01/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88Deco%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/01/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88Deco%EF%BC%89/" class="post-title-link" itemprop="url">end to end源码解析（Deco）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-01T00:00:00+08:00">2025-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 11:10:30" itemprop="dateModified" datetime="2025-04-14T11:10:30+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end源码解析（Deco）融合全局与局部编码器</h1>
<h2 id="weights-init-normal">weights_init_normal</h2>
<p>这段代码的总体意图是为神经网络中的卷积层（Conv1d/Conv2d）和批归一化层（BatchNorm1d/BatchNorm2d）提供权重和偏置的==初始化==方法。卷积层权重用均值 0、标准差 0.02 的正态分布，批归一化层权重用均值 1、标准差 0.02 的正态分布，偏置则设为 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">weights_init_normal</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用正态分布初始化网络权重(Xavier初始化变体)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        m: 待初始化的网络层模块</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    初始化规则:</span></span><br><span class="line"><span class="string">        - 卷积层(Conv1d/Conv2d): 权重 ~ N(0, 0.02)</span></span><br><span class="line"><span class="string">        - 批归一化层(BatchNorm): </span></span><br><span class="line"><span class="string">            - 权重 ~ N(1, 0.02)</span></span><br><span class="line"><span class="string">            - 偏置 = 0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    classname = m.__class__.__name__</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理2D卷积层</span></span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&quot;Conv2d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">0.0</span>, <span class="number">0.02</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理1D卷积层    </span></span><br><span class="line">    <span class="keyword">elif</span> classname.find(<span class="string">&quot;Conv1d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">0.0</span>, <span class="number">0.02</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理2D批归一化层</span></span><br><span class="line">    <span class="keyword">elif</span> classname.find(<span class="string">&quot;BatchNorm2d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">1.0</span>, <span class="number">0.02</span>)  <span class="comment"># 权重初始化为接近1</span></span><br><span class="line">        torch.nn.init.constant_(m.bias.data, <span class="number">0.0</span>)        <span class="comment"># 偏置初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理1D批归一化层    </span></span><br><span class="line">    <span class="keyword">elif</span> classname.find(<span class="string">&quot;BatchNorm1d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">1.0</span>, <span class="number">0.02</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias.data, <span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="GPDLocalFeat">GPDLocalFeat</h2>
<p>类似GPDNett中GPDLocalFE</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GPDLocalFeat</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    图点云局部特征提取网络(Graph Point cloud Local Feature Extraction)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        configuration: 配置字典，包含卷积层配置参数</span></span><br><span class="line"><span class="string">        bn: 是否使用批归一化 (默认True)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, configuration, bn=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GPDLocalFeat, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.bn = bn  <span class="comment"># 批归一化标志</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理MLP (3-&gt;33-&gt;66-&gt;99)</span></span><br><span class="line">        <span class="variable language_">self</span>.pre_nn_layers = get_mlp_1d([<span class="number">3</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">99</span>], bn=bn)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个残差块 (包含多个图卷积层)</span></span><br><span class="line">        <span class="variable language_">self</span>.residual_block1 = Seq()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(configuration[<span class="string">&quot;conv_n_layers&quot;</span>]):</span><br><span class="line">            <span class="variable language_">self</span>.residual_block1.add_module(</span><br><span class="line">                name=<span class="string">f&quot;conv_<span class="subst">&#123;j&#125;</span>_layer&quot;</span>,</span><br><span class="line">                module=ConvLayer(layer_conf=configuration[<span class="string">&quot;conv_layer&quot;</span>], bn=bn)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二个残差块 (结构与第一个相同)</span></span><br><span class="line">        <span class="variable language_">self</span>.residual_block2 = Seq()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(configuration[<span class="string">&quot;conv_n_layers&quot;</span>]):</span><br><span class="line">            <span class="variable language_">self</span>.residual_block2.add_module(</span><br><span class="line">                name=<span class="string">f&quot;conv_<span class="subst">&#123;j&#125;</span>_layer&quot;</span>,</span><br><span class="line">                module=ConvLayer(layer_conf=configuration[<span class="string">&quot;conv_layer&quot;</span>], bn=bn)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化权重</span></span><br><span class="line">        <span class="variable language_">self</span>._initialize_weights()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_initialize_weights</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化网络权重</span></span><br><span class="line"><span class="string">        - 卷积层和线性层: Xavier正态分布初始化</span></span><br><span class="line"><span class="string">        - 批归一化层: 权重设为1，偏置设为0</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="variable language_">self</span>.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, (nn.Conv1d, nn.Linear)):</span><br><span class="line">                nn.init.xavier_normal_(m.weight)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm1d):</span><br><span class="line">                nn.init.constant_(m.weight, <span class="number">1</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, points</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            points: 输入点云 [B, 3, N]</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            提取的局部特征 [B, C, N]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> points.size(<span class="number">1</span>) == <span class="number">3</span>  <span class="comment"># 确保输入是3D点云</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理</span></span><br><span class="line">        h = <span class="variable language_">self</span>.pre_nn_layers(points)  <span class="comment"># [B, 99, N]</span></span><br><span class="line">        h = h.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># [B, N, 99]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一个残差块</span></span><br><span class="line">        x1, _ = <span class="variable language_">self</span>.residual_block1((h, <span class="literal">None</span>))  <span class="comment"># None表示需要计算图结构</span></span><br><span class="line">        h = x1 + h  <span class="comment"># 残差连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二个残差块</span></span><br><span class="line">        x2, _ = <span class="variable language_">self</span>.residual_block2((h, <span class="literal">None</span>))</span><br><span class="line">        h = x2 + h</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># [B, C, N]</span></span><br></pre></td></tr></table></figure>
<h2 id="GLEncoder">GLEncoder</h2>
<p>这个类实现了一个点云编码器，通过局部和全局编码器提取特征，再通过卷积、线性层和激活函数融合两者，最终输出==综合特征==表示。根据配置，还可以选择返回额外的全局特征。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GLEncoder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    全局-局部特征编码器(Global-Local Encoder)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        conf: 配置字典，包含:</span></span><br><span class="line"><span class="string">            - global_encoder: 全局编码器配置</span></span><br><span class="line"><span class="string">            - GPD_local: 局部编码器配置</span></span><br><span class="line"><span class="string">            - aggr_out_feat: 聚合输出维度</span></span><br><span class="line"><span class="string">        bn: 是否使用批归一化 (默认True)</span></span><br><span class="line"><span class="string">        return_global: 是否返回全局特征 (默认False)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    结构组成:</span></span><br><span class="line"><span class="string">        1. 全局特征编码器(GlobalFeat)</span></span><br><span class="line"><span class="string">        2. 局部特征编码器(GPDLocalFeat)</span></span><br><span class="line"><span class="string">        3. 特征聚合模块(1D卷积+线性变换)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, conf, bn=<span class="literal">True</span>, return_global=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GLEncoder, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 全局特征编码器 (处理整体点云结构)</span></span><br><span class="line">        <span class="variable language_">self</span>.global_encoder = GlobalFeat(</span><br><span class="line">            k=conf[<span class="string">&#x27;global_encoder&#x27;</span>][<span class="string">&#x27;nearest_neighboors&#x27;</span>],  <span class="comment"># K近邻数</span></span><br><span class="line">            emb_dims=conf[<span class="string">&#x27;global_encoder&#x27;</span>][<span class="string">&#x27;latent_dim&#x27;</span>],   <span class="comment"># 输出维度</span></span><br><span class="line">            bn=bn)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 局部特征编码器 (处理局部几何特征)</span></span><br><span class="line">        <span class="variable language_">self</span>.local_encoder = GPDLocalFeat(</span><br><span class="line">            configuration=conf[<span class="string">&#x27;GPD_local&#x27;</span>],</span><br><span class="line">            bn=bn)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 特征聚合参数</span></span><br><span class="line">        global_emb_dim = conf[<span class="string">&#x27;global_encoder&#x27;</span>][<span class="string">&#x27;latent_dim&#x27;</span>]</span><br><span class="line">        output_dim = conf[<span class="string">&quot;aggr_out_feat&quot;</span>]  <span class="comment"># 聚合后的特征维度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 局部特征变换 (1D卷积)</span></span><br><span class="line">        <span class="variable language_">self</span>.nn_local = nn.Conv1d(</span><br><span class="line">            in_channels=<span class="number">99</span>,  <span class="comment"># 固定输入维度</span></span><br><span class="line">            out_channels=output_dim,</span><br><span class="line">            kernel_size=<span class="number">1</span>,  <span class="comment"># 点式卷积</span></span><br><span class="line">            bias=<span class="keyword">not</span> bn)     <span class="comment"># 当使用BN时关闭偏置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 全局特征变换 (线性层)</span></span><br><span class="line">        <span class="variable language_">self</span>.nn_global = nn.Linear(</span><br><span class="line">            in_features=global_emb_dim,</span><br><span class="line">            out_features=output_dim,</span><br><span class="line">            bias=<span class="keyword">not</span> bn)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 聚合后处理</span></span><br><span class="line">        <span class="variable language_">self</span>.nn_aggr_bn = nn.BatchNorm1d(output_dim) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity()</span><br><span class="line">        <span class="variable language_">self</span>.nn_aggr_relu = nn.LeakyReLU(negative_slope=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.return_global = return_global  <span class="comment"># 控制是否返回全局特征</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, points</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            points: 输入点云 [B, 3, N] 或 [B, N, 3]</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            当return_global=True: </span></span><br><span class="line"><span class="string">                (局部特征, 全局特征) </span></span><br><span class="line"><span class="string">            否则:</span></span><br><span class="line"><span class="string">                仅返回局部特征</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 统一输入格式为[B, 3, N]</span></span><br><span class="line">        <span class="keyword">if</span> points.shape[<span class="number">1</span>] != <span class="number">3</span>:</span><br><span class="line">            points = points.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        bs = points.size(<span class="number">0</span>)  <span class="comment"># 批大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 双分支特征提取</span></span><br><span class="line">        l_feat = <span class="variable language_">self</span>.local_encoder(points)  <span class="comment"># 局部特征 [B, 99, N]</span></span><br><span class="line">        g_feat = <span class="variable language_">self</span>.global_encoder(points)  <span class="comment"># 全局特征 [B, 1024]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 特征聚合</span></span><br><span class="line">        l_feat_aggr = <span class="variable language_">self</span>.nn_local(l_feat)  <span class="comment"># 局部特征变换 [B, out_dim, N]</span></span><br><span class="line">        g_feat_aggr = <span class="variable language_">self</span>.nn_global(g_feat).unsqueeze(-<span class="number">1</span>)  <span class="comment"># 全局特征变换 [B, out_dim, 1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 特征融合</span></span><br><span class="line">        feat = l_feat_aggr + g_feat_aggr  <span class="comment"># 广播相加</span></span><br><span class="line">        feat = <span class="variable language_">self</span>.nn_aggr_relu(<span class="variable language_">self</span>.nn_aggr_bn(feat))  <span class="comment"># BN + 激活</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.return_global:</span><br><span class="line">            <span class="comment"># 最大池化获取全局描述符</span></span><br><span class="line">            global_feat = torch.<span class="built_in">max</span>(feat, dim=<span class="number">2</span>)[<span class="number">0</span>]  <span class="comment"># [B, out_dim]</span></span><br><span class="line">            <span class="comment"># 拼接原始全局特征</span></span><br><span class="line">            global_feat = torch.cat([global_feat, g_feat], dim=<span class="number">1</span>)  <span class="comment"># [B, out_dim + 1024]</span></span><br><span class="line">            <span class="keyword">return</span> feat, global_feat</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> feat</span><br></pre></td></tr></table></figure>
<h2 id="build-deco-encoder">build_deco_encoder</h2>
<p>构建一个完整的 DeCo 编码器模型，并根据需要加载预训练权重。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_deco_encoder</span>(<span class="params">bn=<span class="literal">True</span>, config=<span class="literal">None</span>, return_global=<span class="literal">False</span>, no_pretext=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建DeCo编码器模型</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        bn: 是否使用批归一化 (默认True)</span></span><br><span class="line"><span class="string">        config: 配置字典 (必须提供)</span></span><br><span class="line"><span class="string">        return_global: 是否返回全局特征 (默认False)</span></span><br><span class="line"><span class="string">        no_pretext: 是否跳过预训练权重加载 (默认False)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        GLEncoder: 构建好的编码器模型</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    工作流程:</span></span><br><span class="line"><span class="string">        1. 初始化GLEncoder模型</span></span><br><span class="line"><span class="string">        2. 权重初始化</span></span><br><span class="line"><span class="string">        3. 加载预训练权重(可选)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> config <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;必须提供配置参数&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 初始化模型</span></span><br><span class="line">    model = GLEncoder(conf=config, bn=bn, return_global=return_global)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 权重初始化 (仅影响非预训练层)</span></span><br><span class="line">    model.apply(weights_init_normal)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 跳过预训练权重加载</span></span><br><span class="line">    <span class="keyword">if</span> no_pretext:</span><br><span class="line">        print_warn(<span class="string">&quot;跳过预训练权重加载!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取预训练权重路径</span></span><br><span class="line">    local_fe_fn = config[<span class="string">&#x27;pretrain&#x27;</span>][<span class="string">&#x27;checkpoint_local_enco&#x27;</span>]  <span class="comment"># 局部编码器权重路径</span></span><br><span class="line">    global_fe_fn = config[<span class="string">&#x27;pretrain&#x27;</span>][<span class="string">&#x27;checkpoint_global_enco&#x27;</span>]  <span class="comment"># 全局编码器权重路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印配置信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    print_bold(<span class="string">f&quot;DeCo配置参数: <span class="subst">&#123;config&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 加载局部编码器预训练权重 (去噪任务)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(local_fe_fn) &gt; <span class="number">0</span>:</span><br><span class="line">        local_enco_dict = torch.load(local_fe_fn)[<span class="string">&#x27;model_state_dict&#x27;</span>]</span><br><span class="line">        loc_load_result = model.local_encoder.load_state_dict(</span><br><span class="line">            local_enco_dict, </span><br><span class="line">            strict=<span class="literal">False</span>  <span class="comment"># 允许部分加载</span></span><br><span class="line">        )</span><br><span class="line">        print_warn(<span class="string">f&quot;局部编码器权重加载结果: \n<span class="subst">&#123;<span class="built_in">str</span>(loc_load_result)&#125;</span>\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print_fail(<span class="string">&quot;未加载局部编码器预训练权重\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 加载全局编码器预训练权重 (对比学习任务)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(global_fe_fn) &gt; <span class="number">0</span>:</span><br><span class="line">        global_enco_dict = torch.load(global_fe_fn)[<span class="string">&#x27;global_encoder&#x27;</span>]</span><br><span class="line">        glob_load_result = model.global_encoder.load_state_dict(</span><br><span class="line">            global_enco_dict,</span><br><span class="line">            strict=bn  <span class="comment"># 根据bn参数决定是否严格匹配</span></span><br><span class="line">        )</span><br><span class="line">        print_warn(<span class="string">f&quot;全局编码器权重加载结果: \n<span class="subst">&#123;<span class="built_in">str</span>(glob_load_result)&#125;</span>\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print_fail(<span class="string">&quot;未加载全局编码器预训练权重\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/31/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88GPDNet%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/31/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88GPDNet%EF%BC%89/" class="post-title-link" itemprop="url">end to end源码解析（GPDNet）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2025-03-31T00:00:00+08:00">2025-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 11:10:32" itemprop="dateModified" datetime="2025-04-14T11:10:32+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end 源码解析（GPDNet）局部敏感</h1>
<p><code>BatchNorm1d</code> 对输入 ( x )（形状 <code>(B, C, N)</code>）的每个通道 ( c ) 进行以下操作：</p>
<ol>
<li>
<p><strong>计算批次均值和方差</strong></p>
<ul>
<li>
<p>均值：<br>
$$<br>
\mu_c = \frac{1}{B \cdot N} \sum_{b=1}^{B} \sum_{n=1}^{N} x_{b,c,n}<br>
$$</p>
</li>
<li>
<p>方差：<br>
$$<br>
\sigma_c^2 = \frac{1}{B \cdot N} \sum_{b=1}^{B} \sum_{n=1}^{N} (x_{b,c,n} - \mu_c)^2<br>
$$</p>
</li>
</ul>
</li>
<li>
<p><strong>归一化</strong></p>
<ul>
<li>
<p>$$<br>
\hat{x} _ {b,c,n}=\frac{x_{b,c,n}-\mu_c}{\sqrt{\sigma_c^2+\epsilon}}<br>
$$</p>
</li>
<li>
<p>$\epsilon$ ：小常数（默认 ( 1e-5 )），防止除以零。</p>
</li>
</ul>
</li>
<li>
<p><strong>缩放和平移</strong></p>
<ul>
<li>
<p>$$<br>
y_{b,c,n} = \gamma_c \cdot \hat{x}_{b,c,n} + \beta_c<br>
$$</p>
</li>
<li>
<p>$\gamma_c$ （<code>weight</code>）：缩放参数，形状 <code>(C,)</code>。</p>
</li>
<li>
<p>$\beta_c$ （<code>bias</code>）：平移参数，形状 <code>(C,)</code>。</p>
</li>
</ul>
</li>
</ol>
<h2 id="compute-graph">compute_graph</h2>
<p>计算一个输入特征矩阵 h 的图结构中的距离矩阵（欧几里得距离）</p>
<p><img src="https://raw.githubusercontent.com/xiaole-cumt/blog-img/main/image-20250401151816127.png" alt="image-20250401151816127"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_graph</span>(<span class="params">h</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算点云图中节点间的距离矩阵</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        h: 输入点云特征张量，形状为(batch_size, num_points, feature_dim)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        D: 距离矩阵，形状为(batch_size, num_points, num_points)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sq_norms = h * h  <span class="comment"># 逐元素平方 [B,N,F]</span></span><br><span class="line">    sq_norms = torch.<span class="built_in">sum</span>(sq_norms, <span class="number">2</span>)  <span class="comment"># 沿特征维度求和 [B,N]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算距离矩阵</span></span><br><span class="line">    D = torch.<span class="built_in">abs</span>(</span><br><span class="line">        sq_norms.unsqueeze(<span class="number">2</span>) +  <span class="comment"># [B,N,1]</span></span><br><span class="line">        sq_norms.unsqueeze(<span class="number">1</span>) -   <span class="comment"># [B,1,N] </span></span><br><span class="line">        <span class="number">2</span> * torch.matmul(h, h.transpose(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># [B,N,N]</span></span><br><span class="line">    )  <span class="comment"># 最终形状 [B,N,N]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> D</span><br></pre></td></tr></table></figure>
<h2 id="myroll">myroll</h2>
<p>通过计算一个分割位置，将张量的两部分交换并拼接，从而实现类似循环移位的效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myroll</span>(<span class="params">h, shift=<span class="number">0</span>, axis=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现张量的循环移位操作</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        h: 输入张量</span></span><br><span class="line"><span class="string">        shift: 移位步数(默认为0)</span></span><br><span class="line"><span class="string">        axis: 沿哪个维度进行移位(默认为第2维度)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        循环移位后的张量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    工作原理:</span></span><br><span class="line"><span class="string">        1. 计算移位后的分界点d = 总长度 - 移位步数</span></span><br><span class="line"><span class="string">        2. 将张量在指定维度上分成两部分并交换位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    h_len = h.size()[<span class="number">2</span>]  <span class="comment"># 获取指定维度的长度</span></span><br><span class="line">    d = <span class="built_in">int</span>(h_len - shift)  <span class="comment"># 计算分割点位置</span></span><br><span class="line">    <span class="keyword">return</span> torch.cat(</span><br><span class="line">        (h[:, :, d:],   <span class="comment"># 取后半部分(从d到结尾)</span></span><br><span class="line">         h[:, :, :d]),  <span class="comment"># 取前半部分(从开始到d)</span></span><br><span class="line">        dim=axis)        <span class="comment"># 沿指定维度拼接</span></span><br></pre></td></tr></table></figure>
<h2 id="index-points">index_points</h2>
<p>index_points 函数根据给定的索引 idx 从输入批次 batch 中提取样本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_points</span>(<span class="params">batch, idx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据索引从批量数据中选择特定点</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        batch: 输入数据 [B, N, C] </span></span><br><span class="line"><span class="string">            B - 批量大小</span></span><br><span class="line"><span class="string">            N - 点数 </span></span><br><span class="line"><span class="string">            C - 特征维度</span></span><br><span class="line"><span class="string">        idx: 索引数据 [B, S]</span></span><br><span class="line"><span class="string">            S - 要选择的点数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        new_batch: 索引后的数据 [B, S, C]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    工作原理:</span></span><br><span class="line"><span class="string">        1. 创建与idx形状匹配的批量索引</span></span><br><span class="line"><span class="string">        2. 使用高级索引从batch中提取对应点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    device = batch.device  <span class="comment"># 获取输入数据所在设备(CPU/GPU)</span></span><br><span class="line">    B = batch.shape[<span class="number">0</span>]     <span class="comment"># 批量大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备索引形状 [B, 1] 用于广播</span></span><br><span class="line">    view_shape = <span class="built_in">list</span>(idx.shape)</span><br><span class="line">    view_shape[<span class="number">1</span>:] = [<span class="number">1</span>] * (<span class="built_in">len</span>(view_shape) - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备重复形状 [1, S] 用于广播，重复在第二个维度</span></span><br><span class="line">    repeat_shape = <span class="built_in">list</span>(idx.shape)</span><br><span class="line">    repeat_shape[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建批量索引 [0,1,...,B-1] 并调整为匹配idx的形状</span></span><br><span class="line">    batch_indices = torch.arange(B, dtype=torch.long).to(device)</span><br><span class="line">    batch_indices = batch_indices.view(view_shape).repeat(repeat_shape)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用高级索引提取数据</span></span><br><span class="line">    new_batch = batch[batch_indices, idx, :]</span><br><span class="line">    <span class="keyword">return</span> new_batch</span><br></pre></td></tr></table></figure>
<h2 id="GConv">GConv</h2>
<blockquote>
<p>输入特征 h [B, N, in_feat]<br>
│<br>
├─ 动态邻居选择 → 邻居特征 x_tilde1, x_tilde2<br>
│  │<br>
│  └─ 特征差异 labels = x_tilde1 - x_tilde2<br>
│<br>
├─ 特征变换: labels → F.relu(Linear(in_feat→fnet_feat))<br>
│<br>
├─ 多尺度拼接: labels1 (stride_th1), labels2 (stride_th2)<br>
│<br>
├─ 低秩权重生成:<br>
│   ├─ theta1<br>
│   ├─ theta2<br>
│   └─ thetal<br>
│<br>
├─ 动态卷积计算:<br>
│   x = theta1 @ x_tilde1 → 加权 → theta2 @ x → 输出<br>
│<br>
├─ 邻域聚合: 距离加权求和，距离越近的点权重越大<br>
│<br>
输出特征</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GConv</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    图卷积网络层(Graph Convolution Layer)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    功能:</span></span><br><span class="line"><span class="string">        基于距离矩阵的图卷积操作，聚合局部邻域特征</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        in_feat: 输入特征维度</span></span><br><span class="line"><span class="string">        fnet_feat: 中间特征网络维度  </span></span><br><span class="line"><span class="string">        out_feat: 输出特征维度</span></span><br><span class="line"><span class="string">        rank_theta: theta矩阵的秩</span></span><br><span class="line"><span class="string">        stride_th1/2: theta1/2的步长</span></span><br><span class="line"><span class="string">        min_nn: 最小邻居数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_feat, fnet_feat, out_feat,</span></span><br><span class="line"><span class="params">                 rank_theta, stride_th1, stride_th2, min_nn</span>):</span><br><span class="line">        <span class="built_in">super</span>(GConv, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="comment"># 初始化各维度参数</span></span><br><span class="line">        <span class="variable language_">self</span>.in_feat = in_feat</span><br><span class="line">        <span class="variable language_">self</span>.fnet_feat = fnet_feat</span><br><span class="line">        <span class="variable language_">self</span>.out_feat = out_feat</span><br><span class="line">        <span class="variable language_">self</span>.rank_theta = rank_theta</span><br><span class="line">        <span class="variable language_">self</span>.stride_th1 = stride_th1</span><br><span class="line">        <span class="variable language_">self</span>.stride_th2 = stride_th2</span><br><span class="line">        <span class="variable language_">self</span>.min_nn = min_nn</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化可学习参数通过合适的初始化方法，保证梯度流的正常</span></span><br><span class="line">        <span class="comment"># 第一层变换矩阵和偏置</span></span><br><span class="line">        <span class="variable language_">self</span>.W_flayer_th0 = torch.nn.Parameter(data=torch.Tensor(in_feat, fnet_feat), requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.xavier_normal_(<span class="variable language_">self</span>.W_flayer_th0, gain=<span class="number">1.0</span>)</span><br><span class="line">        <span class="variable language_">self</span>.b_flayer_th0 = torch.nn.Parameter(data=torch.Tensor(<span class="number">1</span>, fnet_feat), requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.zeros_(<span class="variable language_">self</span>.b_flayer_th0)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># theta1相关参数</span></span><br><span class="line">        <span class="variable language_">self</span>.W_flayer_th1 = torch.nn.Parameter(data=torch.Tensor(fnet_feat, <span class="built_in">int</span>(stride_th1) * rank_theta),requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.normal_(<span class="variable language_">self</span>.W_flayer_th1, mean=<span class="number">0</span>, std=<span class="number">1.0</span> / (np.sqrt(fnet_feat + <span class="number">0.0</span>) * np.sqrt(in_feat + <span class="number">0.0</span>)))</span><br><span class="line">        <span class="variable language_">self</span>.b_flayer_th1 = torch.nn.Parameter(data=torch.Tensor(<span class="number">1</span>, rank_theta, in_feat), requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.zeros_(<span class="variable language_">self</span>.b_flayer_th1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># theta2相关参数  </span></span><br><span class="line">        <span class="variable language_">self</span>.W_flayer_th2 = torch.nn.Parameter(data=torch.Tensor(fnet_feat, <span class="built_in">int</span>(stride_th2) * rank_theta),requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.normal_(<span class="variable language_">self</span>.W_flayer_th2, mean=<span class="number">0</span>, std=<span class="number">1.0</span> / (np.sqrt(fnet_feat + <span class="number">0.0</span>) * np.sqrt(in_feat + <span class="number">0.0</span>)))</span><br><span class="line">        <span class="variable language_">self</span>.b_flayer_th2 = torch.nn.Parameter(data=torch.Tensor(<span class="number">1</span>, rank_theta, out_feat), requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.zeros_(<span class="variable language_">self</span>.b_flayer_th2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最后一层参数</span></span><br><span class="line">        <span class="variable language_">self</span>.W_flayer_thl = torch.nn.Parameter(data=torch.Tensor(fnet_feat, rank_theta), requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.normal_(<span class="variable language_">self</span>.W_flayer_thl, mean=<span class="number">0</span>, std=<span class="number">1.0</span> / np.sqrt(rank_theta + <span class="number">0.0</span>))</span><br><span class="line">        <span class="variable language_">self</span>.b_flayer_thl = torch.nn.Parameter(data=torch.Tensor(<span class="number">1</span>, rank_theta), requires_grad=<span class="literal">True</span>)</span><br><span class="line">        torch.nn.init.zeros_(<span class="variable language_">self</span>.b_flayer_thl)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, h, D</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            h: 输入特征 [B,N,in_feat]</span></span><br><span class="line"><span class="string">            D: 距离矩阵 [B,N,N]</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            图卷积后的特征 [B,out_feat,N]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        B, N, f = h.size()</span><br><span class="line">        <span class="keyword">assert</span> f == <span class="variable language_">self</span>.in_feat</span><br><span class="line">        <span class="keyword">assert</span> D <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 获取每个点的min_nn个最近邻索引，+1是因为点本身和自己距离为0</span></span><br><span class="line">        _, top_idx = torch.topk(-D, k=<span class="variable language_">self</span>.min_nn+<span class="number">1</span>, dim=-<span class="number">1</span>)  <span class="comment"># [B,N,min_nn+1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 构建邻域特征</span></span><br><span class="line">        <span class="comment"># top_idx2: 中心点索引 [B,N*min_nn]2</span></span><br><span class="line">        <span class="comment"># top_idx: 邻域点索引 [B,N*min_nn]</span></span><br><span class="line">        top_idx2 = top_idx[:,:,<span class="number">0</span>].repeat_interleave(<span class="variable language_">self</span>.min_nn, <span class="number">1</span>)</span><br><span class="line">        top_idx = top_idx[:,:,<span class="number">1</span>:].reshape(-<span class="number">1</span>, N*<span class="variable language_">self</span>.min_nn)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 计算相对特征(邻域点特征-中心点特征)</span></span><br><span class="line">        x_tilde1 = index_points(h, top_idx)  <span class="comment"># 邻域点特征 [B,N*min_nn,in_feat]</span></span><br><span class="line">        x_tilde2 = index_points(h, top_idx2)  <span class="comment"># 中心点特征 [B,N*min_nn,in_feat]</span></span><br><span class="line">        labels = x_tilde1 - x_tilde2  <span class="comment"># 相对特征 [B,N*min_nn,in_feat]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># [B*N*min_nn, in_feat]</span></span><br><span class="line">        x_tilde1 = x_tilde1.view(-<span class="number">1</span>, <span class="variable language_">self</span>.in_feat)  </span><br><span class="line">        <span class="comment">#[B*N*min_nn, in_feat]  </span></span><br><span class="line">        labels = labels.view(-<span class="number">1</span>, <span class="variable language_">self</span>.in_feat)</span><br><span class="line">        <span class="comment"># 计算特征差的平方和作为距离度量，并重塑为[B*N, min_nn]形状</span></span><br><span class="line">        d_labels = torch.<span class="built_in">sum</span>(labels * labels, dim=<span class="number">1</span>).view(-<span class="number">1</span>, <span class="variable language_">self</span>.min_nn)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 特征变换和非线性激活</span></span><br><span class="line">        labels = F.leaky_relu(labels @ <span class="variable language_">self</span>.W_flayer_th0 + <span class="variable language_">self</span>.b_flayer_th0, <span class="number">0.02</span>)</span><br><span class="line">        labels_exp = labels.unsqueeze(<span class="number">1</span>)  <span class="comment"># (B*N*min_nn, 1, fnet_feat)</span></span><br><span class="line">        <span class="comment">#拼接多尺度特征</span></span><br><span class="line">        labels1 = labels_exp + <span class="number">0.0</span>  <span class="comment"># [B*N*min_nn, 1, fnet_feat]，创建拷贝，避免修改原数据</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="variable language_">self</span>.in_feat / <span class="variable language_">self</span>.stride_th1)):</span><br><span class="line">            labels1 = torch.cat((labels1, myroll(labels_exp, shift=(ss + <span class="number">1</span>) * <span class="variable language_">self</span>.stride_th1, axis=<span class="number">2</span>)),axis=<span class="number">1</span>)  </span><br><span class="line">            <span class="comment"># [B*N*min_nn, in_feat/stride_th1, fnet_feat]</span></span><br><span class="line"></span><br><span class="line">        labels2 = labels_exp + <span class="number">0.0</span>  <span class="comment"># [B*N*min_nn，1, fnet_feat]</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(<span class="variable language_">self</span>.out_feat / <span class="variable language_">self</span>.stride_th2)):</span><br><span class="line">            labels2 = torch.cat((labels2, myroll(labels_exp, shift=(ss + <span class="number">1</span>) * <span class="variable language_">self</span>.stride_th2, axis=<span class="number">2</span>)),axis=<span class="number">1</span>)  </span><br><span class="line">            <span class="comment"># [B*N*min_nn, out_feat/stride_th2, fnet_feat]</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 5.生成动态卷积核，注意！！代码labels1.view(-1, self.in_feat)中in_feat应该是fnet_feat</span></span><br><span class="line">        theta1 = torch.matmul(labels1.view(-<span class="number">1</span>, <span class="variable language_">self</span>.in_feat), <span class="variable language_">self</span>.W_flayer_th1)</span><br><span class="line">        theta1 = theta1.view(-<span class="number">1</span>, <span class="variable language_">self</span>.rank_theta, <span class="variable language_">self</span>.in_feat) + <span class="variable language_">self</span>.b_flayer_th1</span><br><span class="line">        <span class="comment"># [B*N*min_nn*(in_feat/stride_th1), rank_theta, in_feat]</span></span><br><span class="line">        </span><br><span class="line">        theta2 = torch.matmul(labels2.view(-<span class="number">1</span>, <span class="variable language_">self</span>.in_feat), <span class="variable language_">self</span>.W_flayer_th2)</span><br><span class="line">        theta2 = theta2.view(-<span class="number">1</span>, <span class="variable language_">self</span>.rank_theta, <span class="variable language_">self</span>.out_feat) + <span class="variable language_">self</span>.b_flayer_th2</span><br><span class="line">        <span class="comment"># [B*N*min_nn*(out_feat/stride_th2), rank_theta, out_feat]</span></span><br><span class="line">        <span class="comment"># 注意力权重</span></span><br><span class="line">        thetal = torch.matmul(labels, <span class="variable language_">self</span>.W_flayer_thl) + <span class="variable language_">self</span>.b_flayer_thl  <span class="comment">#  [B*N*min_nn, rank_theta]</span></span><br><span class="line">        thetal = thetal.unsqueeze(<span class="number">2</span>)  <span class="comment"># [B*N*min_nn, rank_theta, 1]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 6.图卷积运算</span></span><br><span class="line">        x = torch.matmul(theta1, x_tilde1.unsqueeze(<span class="number">2</span>))  <span class="comment"># [B*N*min_nn*(in_feat/stride_th1), rank_theta, 1]</span></span><br><span class="line">        x = torch.mul(x, thetal) <span class="comment"># [B*N*min_nn*(in_feat/stride_th1), rank_theta, 1]</span></span><br><span class="line">        x = torch.matmul(theta2.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>), x)[:, :, <span class="number">0</span>]  <span class="comment"># [B*N*min_nn*(out_feat/stride_th2), out_feat]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 7.聚合邻域特征</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="variable language_">self</span>.min_nn, <span class="variable language_">self</span>.out_feat)  <span class="comment"># [B*N*(out_feat/stride_th2), min_nn, out_feat]</span></span><br><span class="line">        x = torch.mul(x, torch.exp(-torch.div(d_labels, <span class="number">10</span>)).unsqueeze(<span class="number">2</span>))  </span><br><span class="line">        <span class="comment"># [B*N*(out_feat/stride_th2), min_nn, out_feat]，距离越近的点权重越大</span></span><br><span class="line">        x = torch.<span class="built_in">sum</span>(x, <span class="number">1</span>).reshape(-<span class="number">1</span>, <span class="variable language_">self</span>.out_feat, N)  <span class="comment"># [B*(out_feat/stride_th2), out_feat, N]</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="ConvLayer">ConvLayer</h2>
<p>ConvLayer 是一个图卷积层，旨在通过图卷积（GConv）处理来增强节点特征。它可以作为中间层（带批归一化和非线性激活）或最后一层（无这些操作）</p>
<blockquote>
<p>layer_conf：一个字典，包含层的配置参数。</p>
<p>bn：布尔值，表示是否使用批归一化（默认 True）。</p>
<p>last：布尔值，表示是否为最后一层（默认 False）。</p>
</blockquote>
<p>​														自环</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>作用</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">保留节点自身信息</td>
<td>在图卷积中只聚合邻居特征可能导致节点自身特征被稀释，自环机制确保节点原始特征被显式考虑，避免信息丢失。</td>
</tr>
<tr>
<td style="text-align:center">增强局部表达能力</td>
<td>通过对自身特征应用独立线性变换（如 <code>self.sl_W</code>），模型能学习平衡自身与邻居特征的贡献，提升局部模式捕获能力。</td>
</tr>
<tr>
<td style="text-align:center">类似传统 GCN 中的自环</td>
<td>传统 GCN 通过邻接矩阵加单位矩阵（( A’ = A + I )）实现自环，<code>ConvLayer</code> 用卷积操作模拟，效果类似但更灵活。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConvLayer</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    图卷积网络中的卷积层，结合图卷积和自循环连接</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        layer_conf: 层配置字典，包含:</span></span><br><span class="line"><span class="string">            in_feat - 输入特征维度</span></span><br><span class="line"><span class="string">            fnet_feat - 特征网络维度  </span></span><br><span class="line"><span class="string">            out_feat - 输出特征维度</span></span><br><span class="line"><span class="string">            rank_theta - 秩参数</span></span><br><span class="line"><span class="string">            stride_th1/th2 - 步长参数</span></span><br><span class="line"><span class="string">            min_nn - 最小邻居数</span></span><br><span class="line"><span class="string">        bn: 是否使用批归一化 (默认True)</span></span><br><span class="line"><span class="string">        last: 是否为最后一层 (默认False)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, layer_conf, bn=<span class="literal">True</span>, last=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(ConvLayer, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.block_config = layer_conf</span><br><span class="line">        <span class="variable language_">self</span>.last = last</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 图卷积模块 (处理邻域信息)</span></span><br><span class="line">        <span class="variable language_">self</span>.gconv = GConv(in_feat=layer_conf[<span class="string">&#x27;in_feat&#x27;</span>],</span><br><span class="line">                         fnet_feat=layer_conf[<span class="string">&#x27;fnet_feat&#x27;</span>],</span><br><span class="line">                         out_feat=layer_conf[<span class="string">&#x27;out_feat&#x27;</span>],</span><br><span class="line">                         rank_theta=layer_conf[<span class="string">&#x27;rank_theta&#x27;</span>],</span><br><span class="line">                         stride_th1=layer_conf[<span class="string">&#x27;stride_th1&#x27;</span>],</span><br><span class="line">                         stride_th2=layer_conf[<span class="string">&#x27;stride_th2&#x27;</span>],</span><br><span class="line">                         min_nn=layer_conf[<span class="string">&#x27;min_nn&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自循环连接参数 (保留节点自身特征)</span></span><br><span class="line">        <span class="comment"># 权重形状: [out_feat, in_feat, 1]</span></span><br><span class="line">        <span class="variable language_">self</span>.sl_W = nn.Parameter(torch.Tensor(layer_conf[<span class="string">&#x27;out_feat&#x27;</span>], layer_conf[<span class="string">&#x27;in_feat&#x27;</span>], <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 偏置形状: [out_feat, 1]</span></span><br><span class="line">        <span class="variable language_">self</span>.sl_b = nn.Parameter(torch.Tensor(layer_conf[<span class="string">&#x27;out_feat&#x27;</span>], <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 参数初始化</span></span><br><span class="line">        nn.init.xavier_normal_(<span class="variable language_">self</span>.sl_W, gain=<span class="number">1.0</span>)</span><br><span class="line">        nn.init.zeros_(<span class="variable language_">self</span>.sl_b)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 非最后一层则添加批归一化和激活函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> last:</span><br><span class="line">            <span class="variable language_">self</span>.BN_layer = nn.BatchNorm1d(layer_conf[<span class="string">&#x27;out_feat&#x27;</span>]) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity()</span><br><span class="line">            <span class="variable language_">self</span>.non_lin = nn.LeakyReLU(negative_slope=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lnl_aggregation</span>(<span class="params">self, h_l, h_nl, b</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        局部与非局部特征聚合</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            h_l: 本身特征 (自循环路径) [B, C, N]</span></span><br><span class="line"><span class="string">            h_nl: 邻域特征 (图卷积路径) [B, C, N]</span></span><br><span class="line"><span class="string">            b: 偏置项 [C, 1]</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            聚合后的特征 [B, C, N]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> h_l.size() == h_nl.size()</span><br><span class="line">        <span class="keyword">return</span> torch.div(h_l + h_nl, <span class="variable language_">self</span>.block_config[<span class="string">&#x27;min_nn&#x27;</span>] + <span class="number">1</span>) + b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, t</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            t: 元组 (h, D)</span></span><br><span class="line"><span class="string">                h - 节点特征 [B, N, in_feat]</span></span><br><span class="line"><span class="string">                D - 距离矩阵 [B, N, N] 或 None</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            元组 (output, D)</span></span><br><span class="line"><span class="string">                output - 输出特征 [B, N, out_feat]</span></span><br><span class="line"><span class="string">                D - 计算/更新的距离矩阵</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        h, D = t</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果未提供距离矩阵则计算</span></span><br><span class="line">        <span class="keyword">if</span> D <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            D = compute_graph(h)  <span class="comment"># [B, N, N]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 图卷积路径</span></span><br><span class="line">        h_nl = <span class="variable language_">self</span>.gconv(h, D)  <span class="comment"># [B, out_feat, N]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 自循环路径 (1D卷积实现)</span></span><br><span class="line">        h_sl = F.conv1d(</span><br><span class="line">            <span class="built_in">input</span>=h.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># [B, in_feat, N]</span></span><br><span class="line">            weight=<span class="variable language_">self</span>.sl_W,          <span class="comment"># [out_feat, in_feat, 1]</span></span><br><span class="line">            bias=<span class="literal">None</span>, </span><br><span class="line">            stride=<span class="number">1</span>)  <span class="comment"># [B, out_feat, N]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 特征聚合</span></span><br><span class="line">        h = <span class="variable language_">self</span>.lnl_aggregation(h_sl, h_nl, <span class="variable language_">self</span>.sl_b)  <span class="comment"># [B, out_feat, N]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.last:</span><br><span class="line">            <span class="comment"># 最后一层不添加BN和激活函数</span></span><br><span class="line">            <span class="keyword">return</span> h.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>), D  <span class="comment"># [B, N, out_feat]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 非最后一层处理</span></span><br><span class="line">        h = <span class="variable language_">self</span>.non_lin(<span class="variable language_">self</span>.BN_layer(h))  <span class="comment"># 批归一化 + 激活</span></span><br><span class="line">        <span class="keyword">return</span> h.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>), D  <span class="comment"># [B, N, out_feat]</span></span><br></pre></td></tr></table></figure>
<h2 id="get-mlp-1d">get_mlp_1d</h2>
<p>3维数据处理的一个多层感知机，主要发生在通道维度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_mlp_1d</span>(<span class="params">channels, bn=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建一个1D多层感知器(MLP)序列</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        channels: 列表，包含各层的通道数，例如[in_dim, hidden_dim1, hidden_dim2, ..., out_dim]</span></span><br><span class="line"><span class="string">        bn: 布尔值，是否使用批归一化 (默认True)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        Sequential: 由多个1D卷积层组成的序列，每层包含:</span></span><br><span class="line"><span class="string">            - Conv1d (kernel_size=1)</span></span><br><span class="line"><span class="string">            - BatchNorm1d (如果bn=True)</span></span><br><span class="line"><span class="string">            - LeakyReLU激活函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> Seq(*[</span><br><span class="line">        Seq(</span><br><span class="line">            <span class="comment"># 1D卷积层 (kernel_size=1实现全连接层效果)</span></span><br><span class="line">            nn.Conv1d(channels[i - <span class="number">1</span>], channels[i], kernel_size=<span class="number">1</span>, bias=(<span class="keyword">not</span> bn)),</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 批归一化层 (bn=True时启用)</span></span><br><span class="line">            nn.BatchNorm1d(channels[i]) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity(),</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># LeakyReLU激活函数 (负斜率0.2)</span></span><br><span class="line">            nn.LeakyReLU(negative_slope=<span class="number">0.2</span>)</span><br><span class="line">        ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(channels))  <span class="comment"># 遍历所有相邻通道对</span></span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<h2 id="GPDLocalFE">GPDLocalFE</h2>
<table>
<thead>
<tr>
<th><strong>类名</strong></th>
<th><strong>层级</strong></th>
<th><strong>作用</strong></th>
<th><strong>输入</strong></th>
<th><strong>输出</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GPDLocalFE</code></td>
<td>顶层模块</td>
<td>整体特征提取：从点云坐标生成高维局部特征，包含预处理和残差结构</td>
<td><code>[B, N, 3]</code></td>
<td><code>[B, N, final_out_feat]</code></td>
</tr>
<tr>
<td><code>ConvLayer</code></td>
<td>中间层模块</td>
<td>图卷积层：结合邻居和自环特征，增强局部特征表示，可选后处理</td>
<td><code>(B, N, in_feat), D</code></td>
<td><code>(B, N, out_feat), D</code></td>
</tr>
<tr>
<td><code>GConv</code></td>
<td>底层操作单元</td>
<td>图卷积操作：聚合邻居特征，生成动态卷积核并加权输出新特征</td>
<td><code>(B, N, in_feat), D</code></td>
<td><code>(B, out_feat, N)</code></td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GPDLocalFE</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图点云特征提取网络(Graph Point cloud feature extraction Network)&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化GPDLocalFE网络</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            configuration: 配置字典，包含:</span></span><br><span class="line"><span class="string">                - pre_Nfeat: 预处理层通道数列表</span></span><br><span class="line"><span class="string">                - conv_n_layers: 每个残差块的层数</span></span><br><span class="line"><span class="string">                - conv_layer: 卷积层配置</span></span><br><span class="line"><span class="string">                - lconv_layer: 最后一层配置</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(GPDLocalFE, <span class="variable language_">self</span>).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理层 - 简单的MLP</span></span><br><span class="line">        pre_layers = configuration[<span class="string">&quot;pre_Nfeat&quot;</span>]</span><br><span class="line">        <span class="variable language_">self</span>.pre_nn_layers = get_mlp_1d(pre_layers)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 残差块1，防止梯度消失</span></span><br><span class="line">        <span class="variable language_">self</span>.residual_block1 = Seq()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(configuration[<span class="string">&quot;conv_n_layers&quot;</span>]):</span><br><span class="line">            <span class="variable language_">self</span>.residual_block1.add_module(</span><br><span class="line">                name=<span class="string">f&quot;conv_<span class="subst">&#123;j&#125;</span>_layer&quot;</span>,</span><br><span class="line">                module=ConvLayer(layer_conf=configuration[<span class="string">&quot;conv_layer&quot;</span>])</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 残差块2</span></span><br><span class="line">        <span class="variable language_">self</span>.residual_block2 = Seq()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(configuration[<span class="string">&quot;conv_n_layers&quot;</span>]):</span><br><span class="line">            <span class="variable language_">self</span>.residual_block2.add_module(</span><br><span class="line">                name=<span class="string">f&quot;conv_<span class="subst">&#123;j&#125;</span>_layer&quot;</span>, </span><br><span class="line">                module=ConvLayer(layer_conf=configuration[<span class="string">&quot;conv_layer&quot;</span>])</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后一层</span></span><br><span class="line">        last_l_conf = configuration[<span class="string">&quot;lconv_layer&quot;</span>]</span><br><span class="line">        <span class="variable language_">self</span>.l_conv = ConvLayer(layer_conf=last_l_conf, last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 权重初始化</span></span><br><span class="line">        <span class="variable language_">self</span>._initialize_weights()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_initialize_weights</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用Xavier方法初始化权重&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="variable language_">self</span>.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, (nn.Conv1d, nn.Linear)):</span><br><span class="line">                nn.init.xavier_normal_(m.weight)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm1d):</span><br><span class="line">                nn.init.constant_(m.weight, <span class="number">1</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, points</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            points: 输入点云数据 [B, N, 3]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            提取的特征 [B, N, out_feat]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 维度转换 [B, N, 3] -&gt; [B, 3, N]</span></span><br><span class="line">        points = points.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 预处理层</span></span><br><span class="line">        h = <span class="variable language_">self</span>.pre_nn_layers(points).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 残差块1</span></span><br><span class="line">        x1, _ = <span class="variable language_">self</span>.residual_block1((h, <span class="literal">None</span>))</span><br><span class="line">        h = x1 + h  <span class="comment"># 残差连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 残差块2</span></span><br><span class="line">        x2, _ = <span class="variable language_">self</span>.residual_block2((h, <span class="literal">None</span>))</span><br><span class="line">        h = x2 + h  <span class="comment"># 残差连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后一层</span></span><br><span class="line">        x3, _ = <span class="variable language_">self</span>.l_conv((h, <span class="literal">None</span>))</span><br><span class="line">        <span class="keyword">return</span> x3</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/28/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88deco_utils%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/28/end%20to%20end%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88deco_utils%EF%BC%89/" class="post-title-link" itemprop="url">end to end源码解析（deco_utils）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-03-28T00:00:00+08:00">2025-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 11:10:16" itemprop="dateModified" datetime="2025-04-14T11:10:16+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end源码解析（deco_utils）全局特征</h1>
<h2 id="Identity">Identity</h2>
<p>一个简单的<strong>恒等层</strong>，即在前向传播过程中直接返回输入，不做任何修改。主要在于残差层的链接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Identity</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Simple Identity layer &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Identity, <span class="variable language_">self</span>).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h2 id="weights-init-normal">weights_init_normal</h2>
<p>对于卷积层和归一化层的参数进行初始化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">weights_init_normal</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Weights initialization with normal distribution.. Xavier &quot;&quot;&quot;</span></span><br><span class="line">    classname = m.__class__.__name__</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&quot;Conv2d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">0.0</span>, <span class="number">0.02</span>)</span><br><span class="line">    <span class="keyword">elif</span> classname.find(<span class="string">&quot;Conv1d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">0.0</span>, <span class="number">0.02</span>)</span><br><span class="line">    <span class="keyword">elif</span> classname.find(<span class="string">&quot;BatchNorm2d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">1.0</span>, <span class="number">0.02</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias.data, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">elif</span> classname.find(<span class="string">&quot;BatchNorm1d&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">        torch.nn.init.normal_(m.weight.data, <span class="number">1.0</span>, <span class="number">0.02</span>)</span><br><span class="line">        torch.nn.init.constant_(m.bias.data, <span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="sanitize-model-dict">sanitize_model_dict</h2>
<p>移除保存模型的多级前缀</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sanitize_model_dict</span>(<span class="params">state_dict, to_remove_str=<span class="string">&#x27;module&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;   </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        state_dict: 原始模型状态字典</span></span><br><span class="line"><span class="string">        to_remove_str: 需要移除的前缀字符串(默认&#x27;module&#x27;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        清理后的新状态字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建新的有序字典存储处理后的参数</span></span><br><span class="line">    new_state_dict = OrderedDict()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算需要移除的前缀长度(加1是为了移除后面的点号)</span></span><br><span class="line">    remove_len = <span class="built_in">len</span>(to_remove_str) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历原始状态字典中的所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> state_dict.items():</span><br><span class="line">        <span class="comment"># 检查键是否以指定前缀开头</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>(k).startswith(to_remove_str):</span><br><span class="line">            <span class="comment"># 移除前缀后的新键名</span></span><br><span class="line">            name = k[remove_len:]  </span><br><span class="line">            new_state_dict[name] = v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 保留不需要处理的键</span></span><br><span class="line">            new_state_dict[k] = v</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> new_state_dict</span><br></pre></td></tr></table></figure>
<h2 id="knn">knn</h2>
<p>计算k个最近邻</p>
<p>推导：假设两个点<br>
$$<br>
(x_{1}-x_{2})^{2}+(x_{1}-y_{2})^{2}+(z_{1}-z_{1})^{2}=x_1^2+y_1^2+z_1^2+x_2^2+y_2^2+z_2^2-2(x_{1}x_{2}+y_{1}y_{2}+z_{1}z_{2})<br>
$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knn</span>(<span class="params">x, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算点云中每个点的k个最近邻点索引</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        x: 输入点云张量，形状为(batch_size, num_dims=3, num_points)</span></span><br><span class="line"><span class="string">        k: 要查找的最近邻点数量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        每个点的k个最近邻点索引，形状为(batch_size, num_points, k)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算内积矩阵: x^T * x</span></span><br><span class="line">    inner = -<span class="number">2</span> * torch.matmul(x.transpose(<span class="number">2</span>, <span class="number">1</span>), x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算每个点的平方和(x_i^2 + y_i^2 + z_i^2)</span></span><br><span class="line">    xx = torch.<span class="built_in">sum</span>(x ** <span class="number">2</span>, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算成对距离矩阵</span></span><br><span class="line">    pairwise_distance = -xx - inner - xx.transpose(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取距离最小的k个点的索引，最大负距离就是最小距离</span></span><br><span class="line">    idx = pairwise_distance.topk(k=k, dim=-<span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># [1]获取索引而非值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> idx</span><br></pre></td></tr></table></figure>
<h2 id="get-graph-feature">get_graph_feature</h2>
<p>构造差异特征，做出更好的特征信息。输出维度顺序：batch_size, 特征通道, 点数, 邻居数</p>
<p><strong>重点关注相对坐标</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_graph_feature</span>(<span class="params">x, k=<span class="number">20</span>, idx=<span class="literal">None</span>, dim9=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    构建点云图特征</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        x: 输入点云张量 (batch_size, num_dims, num_points)</span></span><br><span class="line"><span class="string">        k: 近邻点数量</span></span><br><span class="line"><span class="string">        idx: 预计算的近邻索引(可选)</span></span><br><span class="line"><span class="string">        dim9: 是否忽略法线信息(当输入包含法线时设为True)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        图特征张量 (batch_size, 2*num_dims, num_points, k)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取输入张量尺寸</span></span><br><span class="line">    batch_size = x.size(<span class="number">0</span>)</span><br><span class="line">    num_points = x.size(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调整张量形状</span></span><br><span class="line">    x = x.view(batch_size, -<span class="number">1</span>, num_points)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算或使用预提供的近邻索引</span></span><br><span class="line">    <span class="keyword">if</span> idx <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> dim9:</span><br><span class="line">            <span class="comment"># 忽略法线信息(使用第6维及之后的特征)</span></span><br><span class="line">            idx = knn(x[:, <span class="number">6</span>:], k=k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 使用全部特征计算近邻</span></span><br><span class="line">            idx = knn(x, k=k)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理设备兼容性</span></span><br><span class="line">    device = x.device</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建批次索引基址，这样在下面feature里面好索引</span></span><br><span class="line">    idx_base = torch.arange(<span class="number">0</span>, batch_size, device=device).view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * num_points</span><br><span class="line">    idx = idx + idx_base  <span class="comment"># 添加批次偏移量</span></span><br><span class="line">    idx = idx.view(-<span class="number">1</span>)  <span class="comment"># 展平索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取特征维度</span></span><br><span class="line">    _, num_dims, _ = x.size()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调整张量布局</span></span><br><span class="line">    x = x.transpose(<span class="number">2</span>, <span class="number">1</span>).contiguous()<span class="comment">#contiguous()保证张量在内存中连续分布，以便view操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 收集k个近邻点特征</span></span><br><span class="line">    feature = x.view(batch_size * num_points, -<span class="number">1</span>)[idx, :]</span><br><span class="line">    feature = feature.view(batch_size, num_points, k, num_dims)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构建本身点特征，做k个维度，保证维度匹配来做相对坐标</span></span><br><span class="line">    x = x.view(batch_size, num_points, <span class="number">1</span>, num_dims).repeat(<span class="number">1</span>, <span class="number">1</span>, k, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 组合特征(相对坐标+本身坐标)</span></span><br><span class="line">    feature = torch.cat((feature - x, x), dim=<span class="number">3</span>)  <span class="comment"># 拼接相对和绝对特征</span></span><br><span class="line">    feature = feature.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 调整维度顺序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> feature</span><br></pre></td></tr></table></figure>
<h2 id="batched-index-select">batched_index_select</h2>
<p>是沿着指定的 维度，从x中提取由index指定的所有元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">batched_index_select</span>(<span class="params">x, dim, index</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在指定维度上批量选择张量元素</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        x: 输入张量 (batch_size, ...)</span></span><br><span class="line"><span class="string">        dim: 要执行索引选择的维度</span></span><br><span class="line"><span class="string">        index: 索引张量 (batch_size, num_indices)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        选择后的张量 (batch_size, ..., num_indices, ...)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 为索引添加必要的维度使其与输入张量形状匹配</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x.shape)):</span><br><span class="line">        <span class="keyword">if</span> i != dim:</span><br><span class="line">            index = index.unsqueeze(i)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 准备扩展形状</span></span><br><span class="line">    expanse = <span class="built_in">list</span>(x.shape)</span><br><span class="line">    expanse[<span class="number">0</span>] = -<span class="number">1</span>  <span class="comment"># 保持批次维度不变</span></span><br><span class="line">    expanse[dim] = -<span class="number">1</span>  <span class="comment"># 将被索引维度设置为索引数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 扩展索引以匹配输入张量形状</span></span><br><span class="line">    index = index.expand(expanse)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行索引选择</span></span><br><span class="line">    <span class="keyword">return</span> torch.gather(x, dim, index)</span><br></pre></td></tr></table></figure>
<h2 id="mlp">mlp</h2>
<p>一个多层感知机，经典结构（线性层，归一化层，激活函数层）。但整个网络最后的输出可能要移除后两个层</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mlp</span>(<span class="params">channels</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(*[</span><br><span class="line">        nn.Sequential(nn.Linear(channels[i - <span class="number">1</span>], channels[i]),</span><br><span class="line">                      nn.BatchNorm1d(channels[i]),</span><br><span class="line">                      nn.LeakyReLU(negative_slope=<span class="number">0.2</span>),</span><br><span class="line">                      ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(channels))])</span><br></pre></td></tr></table></figure>
<h2 id="GlobalFeat">GlobalFeat</h2>
<p>通过多个不同的的卷积神经网络，提取输入的多种底层特征，最后拼接在一起，经过一个一维卷积和自适应最大池化，得到一个全局敏感的特征</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GlobalFeat</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    点云全局特征提取网络</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        k: 每个点的最近邻数量，用于构建局部图结构</span></span><br><span class="line"><span class="string">        emb_dims: 最终输出的特征维度</span></span><br><span class="line"><span class="string">        bn: 是否使用批归一化</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    输入:</span></span><br><span class="line"><span class="string">        x: 点云数据，形状(batch_size, 3, num_points)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    输出:</span></span><br><span class="line"><span class="string">        全局特征向量，形状(batch_size, emb_dims)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k=<span class="number">30</span>, emb_dims=<span class="number">1024</span>, bn=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GlobalFeat, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.k = k  <span class="comment"># 局部邻域点数</span></span><br><span class="line">        <span class="variable language_">self</span>.bn = bn  <span class="comment"># 批归一化开关</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 五层特征提取网络</span></span><br><span class="line">        <span class="comment"># 第一层：6通道输入(相对坐标+绝对坐标)，64通道输出</span></span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">6</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity(),</span><br><span class="line">            nn.LeakyReLU(negative_slope=<span class="number">0.2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第二层：128通道输入，64通道输出</span></span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity(),</span><br><span class="line">            nn.LeakyReLU(negative_slope=<span class="number">0.2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第三层：128通道输入，128通道输出</span></span><br><span class="line">        <span class="variable language_">self</span>.conv3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity(),</span><br><span class="line">            nn.LeakyReLU(negative_slope=<span class="number">0.2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第四层：256通道输入，256通道输出</span></span><br><span class="line">        <span class="variable language_">self</span>.conv4 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">256</span>) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity(),</span><br><span class="line">            nn.LeakyReLU(negative_slope=<span class="number">0.2</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第五层：512通道输入，emb_dims输出</span></span><br><span class="line">        <span class="variable language_">self</span>.conv5 = nn.Sequential(</span><br><span class="line">            nn.Conv1d(<span class="number">512</span>, emb_dims, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm1d(emb_dims) <span class="keyword">if</span> bn <span class="keyword">else</span> Identity(),</span><br><span class="line">            nn.LeakyReLU(negative_slope=<span class="number">0.2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前向传播过程：</span></span><br><span class="line"><span class="string">        1. 通过4级特征提取获取多尺度局部特征</span></span><br><span class="line"><span class="string">        2. 拼接所有特征并映射到目标维度</span></span><br><span class="line"><span class="string">        3. 通过全局最大池化得到全局描述符</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        bs, dim, npoints = x.size()</span><br><span class="line">        <span class="keyword">assert</span> dim == <span class="number">3</span>  <span class="comment"># 确保输入是三维坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一级特征提取</span></span><br><span class="line">        x = get_graph_feature(x, k=<span class="variable language_">self</span>.k)  <span class="comment"># 构建局部图特征</span></span><br><span class="line">        <span class="comment"># (bs, 3, npoints) -&gt; (bs, 3*2, npoints, k)</span></span><br><span class="line">        x = <span class="variable language_">self</span>.conv1(x)  <span class="comment"># 卷积处理</span></span><br><span class="line">        <span class="comment"># (bs, 3*2, npoints, k) -&gt; (bs, 64, npoints, k)</span></span><br><span class="line">        x1 = x.<span class="built_in">max</span>(dim=-<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># 最大池化得到局部特征</span></span><br><span class="line">        <span class="comment"># (bs, 64, npoints, k) -&gt; (bs, 64, npoints)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二级特征提取</span></span><br><span class="line">        x = get_graph_feature(x1, k=<span class="variable language_">self</span>.k)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv2(x)</span><br><span class="line">        x2 = x.<span class="built_in">max</span>(dim=-<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">         <span class="comment"># (bs, 64, npoints)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三级特征提取</span></span><br><span class="line">        x = get_graph_feature(x2, k=<span class="variable language_">self</span>.k)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv3(x)</span><br><span class="line">        x3 = x.<span class="built_in">max</span>(dim=-<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># (bs, 128, npoints)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四级特征提取</span></span><br><span class="line">        x = get_graph_feature(x3, k=<span class="variable language_">self</span>.k)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv4(x)</span><br><span class="line">        x4 = x.<span class="built_in">max</span>(dim=-<span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># (bs, 256, npoints)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 特征融合与映射</span></span><br><span class="line">        x = torch.cat((x1, x2, x3, x4), dim=<span class="number">1</span>)  <span class="comment"># 拼接多级特征</span></span><br><span class="line">        <span class="comment"># (bs, 64+64+128+256, npoints) ==&gt; (bs, emb_dims, npoints)</span></span><br><span class="line">        x = <span class="variable language_">self</span>.conv5(x)  <span class="comment"># 映射到目标维度</span></span><br><span class="line">        <span class="comment"># (bs, 64+64+128+256, in_points) -&gt; (bs, emb_dims, npoints)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 全局特征提取</span></span><br><span class="line">        <span class="keyword">return</span> F.adaptive_max_pool1d(x, <span class="number">1</span>).view(bs, -<span class="number">1</span>)</span><br><span class="line">    	<span class="comment"># (bs, emb_dims, npoints) -&gt; (bs, emb_dims)</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/27/end%20to%20end%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88sample_grasp_dataset%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小乐">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小乐的日记本">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/27/end%20to%20end%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88sample_grasp_dataset%EF%BC%89/" class="post-title-link" itemprop="url">end to end 源码解析（sample_grasp_dataset）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-27 00:00:00" itemprop="dateCreated datePublished" datetime="2025-03-27T00:00:00+08:00">2025-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-14 11:09:56" itemprop="dateModified" datetime="2025-04-14T11:09:56+08:00">2025-04-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1>end to end 源码解析（sample_grasp_dataset）数据处理</h1>
<h2 id="read-camera-info">read_camera_info</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_camera_info</span>(<span class="params">camera_info_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    读取并解析相机信息文件</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        camera_info_file: 包含相机信息的.npy文件路径</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        包含相机信息的字典，格式为:</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &#x27;view0&#x27;: (position, orientation, calibration_matrix),</span></span><br><span class="line"><span class="string">            &#x27;view1&#x27;: (position, orientation, calibration_matrix),</span></span><br><span class="line"><span class="string">            ...</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 加载.npy文件中的相机信息数组</span></span><br><span class="line">    camera_info_array = np.load(camera_info_file)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化空字典用于存储解析后的相机信息</span></span><br><span class="line">    cameraInfoDict = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历数组中的每个相机信息项</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> camera_info_array:</span><br><span class="line">        <span class="comment"># 将相机ID解码为字符串作为字典键</span></span><br><span class="line">        <span class="comment"># 值为包含位置(position)、方向(orientation)和标定矩阵(calibration_matrix)的元组</span></span><br><span class="line">        cameraInfoDict[item[<span class="string">&#x27;id&#x27;</span>].decode()] = (</span><br><span class="line">            item[<span class="string">&#x27;position&#x27;</span>],        <span class="comment"># 相机位置坐标(x,y,z)</span></span><br><span class="line">            item[<span class="string">&#x27;orientation&#x27;</span>],    <span class="comment"># 相机方向(通常用四元数表示)</span></span><br><span class="line">            item[<span class="string">&#x27;calibration_matrix&#x27;</span>]  <span class="comment"># 相机内参矩阵(3x3)</span></span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回包含所有相机信息的字典</span></span><br><span class="line">    <span class="keyword">return</span> cameraInfoDict</span><br></pre></td></tr></table></figure>
<h2 id="random-camera-view">random_camera_view</h2>
<p>随即选取一个相机视角</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">random_camera_view</span>(<span class="params">cameraInfoDict=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从相机信息字典中随机选择一个视角</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        cameraInfoDict: 包含多个视角相机信息的字典，格式为:</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &#x27;view0&#x27;: (position, orientation, calibration_matrix),</span></span><br><span class="line"><span class="string">                &#x27;view1&#x27;: (position, orientation, calibration_matrix),</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        tuple: 包含两个元素:</span></span><br><span class="line"><span class="string">            - 所选视角的相机参数(position, orientation, calibration_matrix)</span></span><br><span class="line"><span class="string">            - 所选视角的索引(整数)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取相机视角的总数量</span></span><br><span class="line">    view_num = <span class="built_in">len</span>(cameraInfoDict)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机选择一个视角索引(0到view_num-1之间的整数)</span></span><br><span class="line">    view = np.random.choice(view_num, <span class="number">1</span>)[<span class="number">0</span>]<span class="comment">#[0]是为了将numpy数组转为Python整数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回对应视角的相机参数和视角索引</span></span><br><span class="line">    <span class="keyword">return</span> cameraInfoDict[<span class="string">&#x27;view%d&#x27;</span> % view], view</span><br></pre></td></tr></table></figure>
<h2 id="exr2tiff">exr2tiff</h2>
<p>将exr转为tiff，但是返回的只有红色通道的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exr2tiff</span>(<span class="params">exrpath</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将EXR格式的深度图像文件转换为TIFF格式的numpy数组</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        exrpath: EXR文件的路径</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        深度图像数据(numpy数组)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 打开EXR文件</span></span><br><span class="line">    File = OpenEXR.InputFile(exrpath)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置像素类型为32位浮点数</span></span><br><span class="line">    PixType = Imath.PixelType(Imath.PixelType.FLOAT)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取图像数据窗口信息</span></span><br><span class="line">    DW = File.header()[<span class="string">&#x27;dataWindow&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算图像尺寸(宽度,高度)</span></span><br><span class="line">    Size = (DW.<span class="built_in">max</span>.x - DW.<span class="built_in">min</span>.x + <span class="number">1</span>, DW.<span class="built_in">max</span>.y - DW.<span class="built_in">min</span>.y + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取RGB三个通道的数据(虽然深度图通常只用R通道)</span></span><br><span class="line">    rgb = [np.frombuffer(File.channel(c, PixType), dtype=np.float32) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;RGB&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 只取R通道数据并reshape为正确尺寸</span></span><br><span class="line">    r = np.reshape(rgb[<span class="number">0</span>], (Size[<span class="number">1</span>], Size[<span class="number">0</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回深度图像数据</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<h2 id="read-image">read_image</h2>
<p>读取图片，将其转为tiff红色，读取地址render{view}Depth0001.exr</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_image</span>(<span class="params">img_root, view</span>):</span><br><span class="line">    img_path = img_root</span><br><span class="line">    <span class="comment"># img = io.imread(img_path+&#x27;/render%d.png&#x27;%(view))</span></span><br><span class="line">    depth = exr2tiff(img_path + <span class="string">&#x27;/render%dDepth0001.exr&#x27;</span> % view)</span><br><span class="line">    <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
<h2 id="quaternion2matrix">quaternion2matrix</h2>
<p>单位四元数转为旋转矩阵</p>
<p>只对于单位四元数情况计算正确，即<br>
$$<br>
w²+x²+y²+z²=1<br>
$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quaternion2matrix</span>(<span class="params">quaternion</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将四元数转换为旋转矩阵</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        quaternion: 形状为[batch_size, 4]的torch张量，表示四元数(w,x,y,z)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        形状为[batch_size, 9]的torch张量，表示旋转矩阵(按行展开)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算四元数各分量的平方</span></span><br><span class="line">    sw = quaternion[:, <span class="number">0</span>] * quaternion[:, <span class="number">0</span>]  <span class="comment"># w²</span></span><br><span class="line">    sx = quaternion[:, <span class="number">1</span>] * quaternion[:, <span class="number">1</span>]  <span class="comment"># x²</span></span><br><span class="line">    sy = quaternion[:, <span class="number">2</span>] * quaternion[:, <span class="number">2</span>]  <span class="comment"># y²</span></span><br><span class="line">    sz = quaternion[:, <span class="number">3</span>] * quaternion[:, <span class="number">3</span>]  <span class="comment"># z²</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算对角线元素</span></span><br><span class="line">    m00 = (sx - sy - sz + sw)  <span class="comment"># 1 - 2y² - 2z²</span></span><br><span class="line">    m11 = (-sx + sy - sz + sw) <span class="comment"># 1 - 2x² - 2z²</span></span><br><span class="line">    m22 = (-sx - sy + sz + sw) <span class="comment"># 1 - 2x² - 2y²</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算非对角线元素</span></span><br><span class="line">    tmp1 = quaternion[:, <span class="number">1</span>] * quaternion[:, <span class="number">2</span>]  <span class="comment"># xy</span></span><br><span class="line">    tmp2 = quaternion[:, <span class="number">3</span>] * quaternion[:, <span class="number">0</span>]  <span class="comment"># zw</span></span><br><span class="line">    m10 = <span class="number">2.0</span> * (tmp1 + tmp2)  <span class="comment"># 2(xy + zw)</span></span><br><span class="line">    m01 = <span class="number">2.0</span> * (tmp1 - tmp2)  <span class="comment"># 2(xy - zw)</span></span><br><span class="line"></span><br><span class="line">    tmp1 = quaternion[:, <span class="number">1</span>] * quaternion[:, <span class="number">3</span>]  <span class="comment"># xz</span></span><br><span class="line">    tmp2 = quaternion[:, <span class="number">2</span>] * quaternion[:, <span class="number">0</span>]  <span class="comment"># yw</span></span><br><span class="line">    m20 = <span class="number">2.0</span> * (tmp1 - tmp2)  <span class="comment"># 2(xz - yw)</span></span><br><span class="line">    m02 = <span class="number">2.0</span> * (tmp1 + tmp2)  <span class="comment"># 2(xz + yw)</span></span><br><span class="line"></span><br><span class="line">    tmp1 = quaternion[:, <span class="number">2</span>] * quaternion[:, <span class="number">3</span>]  <span class="comment"># yz</span></span><br><span class="line">    tmp2 = quaternion[:, <span class="number">1</span>] * quaternion[:, <span class="number">0</span>]  <span class="comment"># xw</span></span><br><span class="line">    m21 = <span class="number">2.0</span> * (tmp1 + tmp2)  <span class="comment"># 2(yz + xw)</span></span><br><span class="line">    m12 = <span class="number">2.0</span> * (tmp1 - tmp2)  <span class="comment"># 2(yz - xw)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将所有元素堆叠成[batch_size, 9]的形状</span></span><br><span class="line">    <span class="keyword">return</span> torch.stack([m00, m01, m02, m10, m11, m12, m20, m21, m22], dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="zMove">zMove</h2>
<p>==迁移注意！==解决原始数据集的z轴偏移问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zMove</span>(<span class="params">quaternion, gripper_position, z_move_length=-<span class="number">0.015</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    修正原始数据集中z轴1.5cm偏移的问题</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        quaternion: 四元数表示夹持器的旋转姿态</span></span><br><span class="line"><span class="string">        gripper_position: 夹持器的当前位置 [x,y,z]</span></span><br><span class="line"><span class="string">        z_move_length: z轴移动距离(默认-0.015米，即1.5cm)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        修正后的夹持器位置</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将输入四元数转换为torch张量</span></span><br><span class="line">    quaternion_ = torch.tensor(quaternion)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将四元数转换为旋转矩阵，并reshape为3x3矩阵</span></span><br><span class="line">    rotation_matrix = quaternion2matrix(quaternion_).numpy().reshape(-<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取旋转矩阵的z轴方向向量</span></span><br><span class="line">    rotation_z = rotation_matrix[:, :, <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算z轴移动向量</span></span><br><span class="line">    move_z = rotation_z * z_move_length</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 修正夹持器位置(远离物体避免碰撞)</span></span><br><span class="line">    gripper_position = gripper_position + move_z</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gripper_position</span><br></pre></td></tr></table></figure>
<h2 id="prune-and-normalize">prune_and_normalize</h2>
<p>剔除超出范围的点和归一化处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">prune_and_normalize</span>(<span class="params">tensor</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将GPNet数据缩放到单位维度，并裁剪超出边界的点</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        tensor: 需要归一化的3D点云张量[N x 3]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        归一化后的点云数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 分解xyz坐标</span></span><br><span class="line">    tensor_x = tensor[:, <span class="number">0</span>]  <span class="comment"># x坐标</span></span><br><span class="line">    tensor_y = tensor[:, <span class="number">1</span>]  <span class="comment"># y坐标</span></span><br><span class="line">    tensor_z = tensor[:, <span class="number">2</span>]  <span class="comment"># z坐标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建删除索引，标记超出边界的点</span></span><br><span class="line">    del_idx = ((tensor_x &lt; -<span class="number">0.22</span> / <span class="number">2</span>) |  <span class="comment"># x小于-0.11</span></span><br><span class="line">               (tensor_x &gt; <span class="number">0.22</span> / <span class="number">2</span>) |   <span class="comment"># x大于0.11</span></span><br><span class="line">               (tensor_y &lt; -<span class="number">0.22</span> / <span class="number">2</span>) |   <span class="comment"># y小于-0.11</span></span><br><span class="line">               (tensor_y &gt; <span class="number">0.22</span> / <span class="number">2</span>) |    <span class="comment"># y大于0.11</span></span><br><span class="line">               (tensor_z &gt; <span class="number">0.22</span>))         <span class="comment"># z大于0.22</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 裁剪超出边界的点，保留范围内的点</span></span><br><span class="line">    tensor = tensor[del_idx == <span class="literal">False</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 归一化到[-1,1]x[-1,1]x[0,1]范围</span></span><br><span class="line">    tensor = tensor / np.array([<span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tensor</span><br></pre></td></tr></table></figure>
<h2 id="get-point-cloud-from-cam-info">get_point_cloud_from_cam_info</h2>
<p>简单来说就是从相机直接获得的深度图转换为我们需要的点云数据，其中会有一些数据处理。比如inf_idx = (pc != pc) | (np.abs(pc) &gt; 100)无效点的去除，above_shelf_indexes = np.nonzero<a href="0">pc[:, 2] &gt; shelf_th</a>高于z轴一定点的去除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_point_cloud_from_cam_info</span>(<span class="params">img_path, camera_pose, view, shelf_th=<span class="number">0.002</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从相机信息生成点云并进行预处理</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        img_path: 图像路径</span></span><br><span class="line"><span class="string">        camera_pose: 相机位姿(位置,方向,内参矩阵)</span></span><br><span class="line"><span class="string">        view: 视角编号</span></span><br><span class="line"><span class="string">        shelf_th: 货架高度阈值(默认0.002米)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        处理后的点云数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 提取相机参数</span></span><br><span class="line">    ca_loc = camera_pose[<span class="number">0</span>]  <span class="comment"># 相机位置</span></span><br><span class="line">    ca_ori = camera_pose[<span class="number">1</span>]  <span class="comment"># 相机方向</span></span><br><span class="line">    intrinsic = camera_pose[<span class="number">2</span>].reshape(<span class="number">3</span>, <span class="number">3</span>)  <span class="comment"># 内参矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取并预处理深度图</span></span><br><span class="line">    depth = read_image(img_path, view)  <span class="comment"># 读取深度图</span></span><br><span class="line">    org_size = depth.shape  <span class="comment"># 原始尺寸</span></span><br><span class="line">    depth = cv2.resize(depth, (<span class="number">224</span>, <span class="number">224</span>), interpolation=cv2.INTER_NEAREST)  <span class="comment"># 调整尺寸</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换为点云，并且转换到世界坐标系下</span></span><br><span class="line">    pc = Depth2PointCloud(depth, intrinsic, ca_ori, ca_loc, org_size=org_size).transpose()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 移除无效点(NaN和过大值)</span></span><br><span class="line">    inf_idx = (pc != pc) | (np.<span class="built_in">abs</span>(pc) &gt; <span class="number">100</span>)  <span class="comment"># 检测无效点</span></span><br><span class="line">    pc[inf_idx] = <span class="number">0.0</span>  <span class="comment"># 无效点置零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 移除货架下方的点(低于阈值)</span></span><br><span class="line">    above_shelf_indexes = np.nonzero(pc[:, <span class="number">2</span>] &gt; shelf_th)[<span class="number">0</span>]  <span class="comment"># z坐标高于阈值的点</span></span><br><span class="line">    pc = pc[above_shelf_indexes]  <span class="comment"># 筛选有效点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pc</span><br></pre></td></tr></table></figure>
<h2 id="travel-image-dir">travel_image_dir</h2>
<p>遍历指定的根目录，收集所有直接位于根目录下的子目录，并将它们的名称与路径存储在字典中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">travel_image_dir</span>(<span class="params">img_root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    遍历图像目录并构建形状名称到路径的映射字典</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        img_root: 图像根目录路径</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        字典&#123;形状名称: 形状路径&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    shape_dir = &#123;&#125;  <span class="comment"># 初始化空字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取目录下所有文件和子目录</span></span><br><span class="line">    shapes = os.listdir(img_root)  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历所有条目</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> shapes:</span><br><span class="line">        <span class="comment"># 构建完整路径</span></span><br><span class="line">        shape_path = osp.join(img_root, s)  </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 只保留目录(过滤掉文件)</span></span><br><span class="line">        <span class="keyword">if</span> osp.isdir(shape_path): <span class="comment">#检查路径是否存在 </span></span><br><span class="line">            shape_dir[s] = shape_path  <span class="comment"># 添加到字典</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> shape_dir</span><br></pre></td></tr></table></figure>
<h2 id="接触面与点云匹配形式">接触面与点云匹配形式</h2>
<blockquote>
<p>contacts: 包含接触点的集合，通常是一组坐标（x, y, z）。<br>
scores: 每个接触点的评分或置信度，表示该点被认为是真实接触点的可能性。<br>
pc: 点云数据，表示3D空间中的点。<br>
contact_th: 接触阈值，用于决定接触点是否被视为有效的接触。<br>
policy: 匹配策略，可选值为’soft’或’hard’，决定匹配的严格程度。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match_contacts_with_pc</span>(<span class="params">contacts, scores, pc, contact_th=<span class="number">0.0035</span>, policy=<span class="string">&#x27;soft&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">assert</span> policy <span class="keyword">in</span> [<span class="string">&#x27;soft&#x27;</span>, <span class="string">&#x27;hard&#x27;</span>], <span class="string">&quot;Must choose between hard or soft matching&quot;</span></span><br><span class="line">    <span class="keyword">if</span> policy == <span class="string">&#x27;soft&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> match_contacts_with_pc_soft(contacts, scores, pc, contact_th=contact_th)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> match_contacts_with_pc_hard(contacts, scores, pc, contact_th=contact_th)</span><br></pre></td></tr></table></figure>
<h3 id="硬性匹配">硬性匹配</h3>
<p>基于欧几里得距离和距离阈值将接触点对与点云中的点进行匹配，选出最近邻</p>
<blockquote>
<p>contacts: 接触点对的集合，形状为 [M x 3 x 2]，表示 M 对接触点，每个接触点有 3 个坐标（x, y, z）。<br>
scores: 握持标签，形状为 [M x 1]，表示每个接触点对的评分或置信度。<br>
pc: 点云数据，形状为 [N x 3]，表示点云中的 N 个点，每个点有 3 个坐标（x, y, z）。<br>
contact_th: 距离阈值，用于判断接触点是否足够接近点云点。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match_contacts_with_pc_hard</span>(<span class="params">contacts, scores, pc, contact_th=<span class="number">0.0035</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将每个接触点对硬匹配到点云中的最近点</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        contacts: 接触点对数组 [M x 3 x 2], 每个元素包含两个3D接触点</span></span><br><span class="line"><span class="string">        scores: 抓取质量标签 [M x 1], 1表示成功抓取</span></span><br><span class="line"><span class="string">        pc: 点云数据 [N x 3]</span></span><br><span class="line"><span class="string">        contact_th: 有效匹配的距离阈值(默认0.0035米)</span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        first_contact_pc_indexes: 正样本接触点对应的点云索引</span></span><br><span class="line"><span class="string">        contact_indexes: 匹配的接触点对信息数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将点云和接触点从归一化坐标还原到原始尺度</span></span><br><span class="line">    scale = np.array([<span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span>])</span><br><span class="line">    pc_rescaled = pc * scale</span><br><span class="line">    </span><br><span class="line">    first_contact_pc_indexes = []  <span class="comment"># 存储正样本接触点对应的点云索引</span></span><br><span class="line">    contact_indexes = []  <span class="comment"># 存储匹配信息(索引, 主接触点, 次接触点)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contacts)):</span><br><span class="line">        score = scores[j]</span><br><span class="line">        c1, c2 = contacts[j][:,<span class="number">0</span>], contacts[j][:,<span class="number">1</span>]  <span class="comment"># 获取当前接触点对（有修正）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 还原接触点原始尺度</span></span><br><span class="line">        c1_rescaled = c1 * scale</span><br><span class="line">        c2_rescaled = c2 * scale</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算点云到两个接触点的距离</span></span><br><span class="line">        dist1 = np.linalg.norm(pc_rescaled - c1_rescaled, axis=<span class="number">1</span>)</span><br><span class="line">        dist2 = np.linalg.norm(pc_rescaled - c2_rescaled, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到最近点的索引和距离</span></span><br><span class="line">        idx1, d1_min = np.argmin(dist1), dist1.<span class="built_in">min</span>()</span><br><span class="line">        idx2, d2_min = np.argmin(dist2), dist2.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果第一个接触点在阈值范围内</span></span><br><span class="line">        <span class="keyword">if</span> d1_min &lt;= contact_th:</span><br><span class="line">            contact_indexes.append((j, <span class="number">0</span>, <span class="number">1</span>))  <span class="comment"># (接触对索引, 主接触点, 配对次接触点)</span></span><br><span class="line">            <span class="keyword">if</span> score == <span class="number">1</span> <span class="keyword">and</span> idx1 <span class="keyword">not</span> <span class="keyword">in</span> first_contact_pc_indexes:</span><br><span class="line">                first_contact_pc_indexes.append(idx1)  <span class="comment"># 只添加正样本</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果第二个接触点在阈值范围内        </span></span><br><span class="line">        <span class="keyword">if</span> d2_min &lt;= contact_th:</span><br><span class="line">            contact_indexes.append((j, <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> score == <span class="number">1</span> <span class="keyword">and</span> idx2 <span class="keyword">not</span> <span class="keyword">in</span> first_contact_pc_indexes:</span><br><span class="line">                first_contact_pc_indexes.append(idx2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换为numpy数组返回</span></span><br><span class="line">    <span class="keyword">return</span> np.array(first_contact_pc_indexes), np.array(contact_indexes)</span><br></pre></td></tr></table></figure>
<h3 id="软匹配">软匹配</h3>
<p>软匹配记录所有满足阈值条件的点，而硬匹配只记录满足阈值的最近点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match_contacts_with_pc_soft</span>(<span class="params">contacts, scores, pc, contact_th=<span class="number">0.0035</span></span>):</span><br><span class="line">    <span class="comment"># 1. 将归一化的点云和接触点还原到原始尺度</span></span><br><span class="line">    pc_rescaled = pc * np.array([<span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 初始化结果容器</span></span><br><span class="line">    first_contact_pc_indexes = []  <span class="comment"># 存储正样本匹配的点云索引</span></span><br><span class="line">    contact_indexes = []  <span class="comment"># 存储匹配信息(接触对索引, 主接触点, 次接触点)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 遍历每个接触点对</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contacts)):</span><br><span class="line">        cont = contacts[j]  <span class="comment"># 获取第j个接触点对</span></span><br><span class="line">        score = scores[j]   <span class="comment"># 获取对应的抓取质量分数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 提取两个接触点</span></span><br><span class="line">        c1, c2 = cont[<span class="number">0</span>], cont[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 5. 还原接触点原始尺度</span></span><br><span class="line">        c1_rescaled = c1 * np.array([<span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span>])</span><br><span class="line">        c2_rescaled = c2 * np.array([<span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 6. 计算点云到两个接触点的距离</span></span><br><span class="line">        dist1 = np.linalg.norm(pc_rescaled - c1_rescaled, axis=<span class="number">1</span>)</span><br><span class="line">        dist2 = np.linalg.norm(pc_rescaled - c2_rescaled, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 7. 找到距离小于阈值的所有点云索引</span></span><br><span class="line">        idxs1 = np.where(dist1 &lt;= contact_th)[<span class="number">0</span>]  <span class="comment"># c1的邻近点</span></span><br><span class="line">        idxs2 = np.where(dist2 &lt;= contact_th)[<span class="number">0</span>]  <span class="comment"># c2的邻近点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 8. 记录匹配信息</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(idxs1) &gt; <span class="number">0</span>:</span><br><span class="line">            contact_indexes.append((j, <span class="number">0</span>, <span class="number">1</span>))  <span class="comment"># (接触对j, 主接触点0, 次接触点1)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(idxs2) &gt; <span class="number">0</span>:</span><br><span class="line">            contact_indexes.append((j, <span class="number">1</span>, <span class="number">0</span>))  <span class="comment"># (接触对j, 主接触点1, 次接触点0)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 9. 如果是正样本(scores=1)，记录匹配的点云索引</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> idxs1:</span><br><span class="line">            <span class="keyword">if</span> score == <span class="number">1</span> <span class="keyword">and</span> idx <span class="keyword">not</span> <span class="keyword">in</span> first_contact_pc_indexes:</span><br><span class="line">                first_contact_pc_indexes.append(idx)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> idxs2:</span><br><span class="line">            <span class="keyword">if</span> score == <span class="number">1</span> <span class="keyword">and</span> idx <span class="keyword">not</span> <span class="keyword">in</span> first_contact_pc_indexes:</span><br><span class="line">                first_contact_pc_indexes.append(idx)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 10. 转换为numpy数组返回</span></span><br><span class="line">    <span class="keyword">return</span> np.array(first_contact_pc_indexes), np.array(contact_indexes)</span><br></pre></td></tr></table></figure>
<h2 id="balance-grasp-indexes">balance_grasp_indexes</h2>
<p>从给定的 scores数组中选择一定数量的正样本和负样本索引，以平衡正负样本的数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">balance_grasp_indexes</span>(<span class="params">scores, sample_num, posi_ratio</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    平衡正负样本索引，确保训练时正负样本比例符合要求</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        scores: 样本标签数组 [M], 1表示正样本(成功抓取), 0表示负样本</span></span><br><span class="line"><span class="string">        sample_num: 需要采样的总样本数</span></span><br><span class="line"><span class="string">        posi_ratio: 正样本在采样结果中的目标比例</span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        selected_idxs: 平衡后的样本索引数组 [sample_num]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 计算需要选取的正负样本数量</span></span><br><span class="line">    sel_posi_num = <span class="built_in">int</span>(sample_num * posi_ratio)  <span class="comment"># 正样本数量</span></span><br><span class="line">    sel_nega_num = sample_num - sel_posi_num    <span class="comment"># 负样本数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取所有正负样本的原始索引</span></span><br><span class="line">    posi_idx = np.where(scores.reshape(-<span class="number">1</span>))[<span class="number">0</span>]    <span class="comment"># 正样本索引</span></span><br><span class="line">    nega_idx = np.where(scores == <span class="number">0</span>)[<span class="number">0</span>]            <span class="comment"># 负样本索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理正样本索引</span></span><br><span class="line">    <span class="keyword">if</span> posi_idx.size &gt;= sel_posi_num:</span><br><span class="line">        <span class="comment"># 正样本充足时，随机选取不重复的样本</span></span><br><span class="line">        idx = np.random.choice(posi_idx.size, sel_posi_num, replace=<span class="literal">False</span>)</span><br><span class="line">        posi_idx = posi_idx[idx]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 正样本不足时，先取全部再随机重复补足</span></span><br><span class="line">        <span class="keyword">if</span> posi_idx.size == <span class="number">0</span>:</span><br><span class="line">            idx = np.array([], dtype=<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = np.random.choice(posi_idx.size, </span><br><span class="line">                                 sel_posi_num - posi_idx.size, </span><br><span class="line">                                 replace=<span class="literal">True</span>)</span><br><span class="line">            idx = np.concatenate([np.arange(posi_idx.size), idx])</span><br><span class="line">        posi_idx = posi_idx[idx]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理负样本索引(逻辑同上)</span></span><br><span class="line">    <span class="keyword">if</span> nega_idx.size &gt;= sel_nega_num:</span><br><span class="line">        idx = np.random.choice(nega_idx.size, sel_nega_num, replace=<span class="literal">False</span>)</span><br><span class="line">        nega_idx = nega_idx[idx]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> nega_idx.size == <span class="number">0</span>:</span><br><span class="line">            idx = np.array([], dtype=<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = np.random.choice(nega_idx.size,</span><br><span class="line">                                 sel_nega_num - nega_idx.size,</span><br><span class="line">                                 replace=<span class="literal">True</span>)</span><br><span class="line">            idx = np.concatenate([np.arange(nega_idx.size), idx])</span><br><span class="line">        nega_idx = nega_idx[idx]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并并打乱顺序</span></span><br><span class="line">    selected_idxs = np.concatenate([posi_idx, nega_idx])</span><br><span class="line">    np.random.shuffle(selected_idxs)</span><br><span class="line">    <span class="keyword">return</span> selected_idxs</span><br></pre></td></tr></table></figure>
<h2 id="SampleGraspData">SampleGraspData</h2>
<p>init初始化根目录，getitem根据索引获取对应形状的抓取信息，readgrasp读取并处理特定形状的抓取标注数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SampleGraspData</span>(data.Dataset):</span><br><span class="line">    <span class="comment"># 初始化数据集类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                 data_root,         <span class="comment"># 数据集根目录路径</span></span></span><br><span class="line"><span class="params">                 split=<span class="string">&#x27;train&#x27;</span>,     <span class="comment"># 数据集划分类型，默认为训练集</span></span></span><br><span class="line"><span class="params">                 view=<span class="number">0</span>,            <span class="comment"># 视角编号，默认为0</span></span></span><br><span class="line"><span class="params">                 img_size=(<span class="params"><span class="number">224</span>, <span class="number">224</span></span>),  <span class="comment"># 图像尺寸，默认为224x224</span></span></span><br><span class="line"><span class="params">                 sample_ratio=<span class="number">1.0</span>,  <span class="comment"># 采样比例，默认为1.0(全部采样)</span></span></span><br><span class="line"><span class="params">                 sample_num=<span class="number">1000</span>,   <span class="comment"># 每个形状的采样数量，默认为1000</span></span></span><br><span class="line"><span class="params">                 tot_num=<span class="number">10000</span>,     <span class="comment"># 总采样数量，默认为10000</span></span></span><br><span class="line"><span class="params">                 positive_ratio=<span class="number">0.5</span>,  <span class="comment"># 正样本比例，默认为0.5</span></span></span><br><span class="line"><span class="params">                 contact_th=<span class="number">0.0035</span>, <span class="comment"># 接触点距离阈值，默认为0.0035</span></span></span><br><span class="line"><span class="params">                 matching_policy=<span class="string">&#x27;soft&#x27;</span></span>):  <span class="comment"># 匹配策略，默认为&#x27;soft&#x27;</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Class for ShapeNetSem-8 and YCB-8</span></span><br><span class="line"><span class="string">        Extracts info from the grasp dataset.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 检查split参数是否合法</span></span><br><span class="line">        <span class="keyword">assert</span> split <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;train_half&#x27;</span>, <span class="string">&#x27;train_quarter&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;ycb8_test&#x27;</span>], <span class="string">f&quot;Unknown split <span class="subst">&#123;split&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化类属性</span></span><br><span class="line">        <span class="variable language_">self</span>.split = split  <span class="comment"># 数据集划分类型</span></span><br><span class="line">        <span class="variable language_">self</span>.data_root = data_root  <span class="comment"># 数据集根目录</span></span><br><span class="line">        <span class="variable language_">self</span>.img_size = img_size  <span class="comment"># 图像尺寸</span></span><br><span class="line">        <span class="variable language_">self</span>.positive_ratio = positive_ratio  <span class="comment"># 正样本比例</span></span><br><span class="line">        <span class="variable language_">self</span>.sample_num = sample_num  <span class="comment"># 每个形状的采样数量</span></span><br><span class="line">        <span class="variable language_">self</span>.tot_num = tot_num  <span class="comment"># 总采样数量</span></span><br><span class="line">        <span class="variable language_">self</span>.matching_policy = matching_policy  <span class="comment"># 匹配策略</span></span><br><span class="line">        <span class="variable language_">self</span>.contact_th = contact_th  <span class="comment"># 接触点距离阈值</span></span><br><span class="line">        <span class="variable language_">self</span>.view = view  <span class="comment"># 视角编号</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印初始化信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;SampleGraspData - data_root: <span class="subst">&#123;self.data_root&#125;</span>, split: <span class="subst">&#123;self.split&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建数据集分割文件的路径</span></span><br><span class="line">        file_path = osp.join(<span class="variable language_">self</span>.data_root, <span class="string">&quot;%s_set.csv&quot;</span> % <span class="variable language_">self</span>.split)</span><br><span class="line">        <span class="comment"># 如果是ycb8_test数据集，修正文件路径</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.split == <span class="string">&quot;ycb8_test&quot;</span>:</span><br><span class="line">            file_path = osp.join(<span class="variable language_">self</span>.data_root, <span class="string">&quot;test_set.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保分割文件存在</span></span><br><span class="line">        <span class="keyword">assert</span> osp.exists(file_path), <span class="string">f&quot;Cannot find split file at <span class="subst">&#123;file_path&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化形状列表</span></span><br><span class="line">        <span class="variable language_">self</span>.shapes = []</span><br><span class="line">        <span class="comment"># 读取分割文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                <span class="comment"># 提取形状名称(去掉文件扩展名)</span></span><br><span class="line">                shape = line.strip().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="variable language_">self</span>.shapes.append(shape)</span><br><span class="line">        <span class="comment"># 确保形状列表不为空</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.shapes) &gt; <span class="number">0</span>, <span class="string">f&quot;Split file <span class="subst">&#123;file_path&#125;</span> is empty&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置点云数据根目录(用于YCB测试数据)</span></span><br><span class="line">        <span class="variable language_">self</span>.pc_root = osp.join(data_root, <span class="string">&#x27;point_clouds&#x27;</span>)</span><br><span class="line">        <span class="comment"># 设置图像数据根目录</span></span><br><span class="line">        <span class="variable language_">self</span>.img_root = osp.join(data_root, <span class="string">&#x27;images&#x27;</span>)</span><br><span class="line">        <span class="comment"># 根据数据集类型选择不同的目录遍历方式</span></span><br><span class="line">        <span class="variable language_">self</span>.shape_dir = travel_image_dir(<span class="variable language_">self</span>.pc_root) <span class="keyword">if</span> <span class="variable language_">self</span>.split == <span class="string">&#x27;ycb8_test&#x27;</span> <span class="keyword">else</span> \</span><br><span class="line">            travel_image_dir(<span class="variable language_">self</span>.img_root)</span><br><span class="line">        <span class="comment"># 设置标注数据根目录</span></span><br><span class="line">        <span class="variable language_">self</span>.anno_root = osp.join(data_root, <span class="string">&#x27;annotations&#x27;</span>)</span><br><span class="line">        <span class="comment"># 设置采样比例</span></span><br><span class="line">        <span class="variable language_">self</span>.sample_ratio = sample_ratio</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回数据集中形状的数量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.shapes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取单个数据项</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># 获取指定索引的形状名称</span></span><br><span class="line">        shape = <span class="variable language_">self</span>.shapes[index]</span><br><span class="line">        <span class="comment"># 读取该形状的抓取数据(相机信息、接触点、角度、分数)</span></span><br><span class="line">        cam_info, contacts, angles, scores = <span class="variable language_">self</span>.read_grasps(shape)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练数据处理流程</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.split.startswith(<span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">            <span class="comment"># 随机选择一个视角</span></span><br><span class="line">            camera_pose, view = random_camera_view(cam_info)</span><br><span class="line">            <span class="comment"># 从相机信息获取点云</span></span><br><span class="line">            pc = get_point_cloud_from_cam_info(<span class="variable language_">self</span>.shape_dir[shape], camera_pose, view)</span><br><span class="line">            <span class="comment"># 对点云进行修剪和归一化</span></span><br><span class="line">            pc = prune_and_normalize(pc)</span><br><span class="line">            <span class="comment"># 对接触点进行修剪和归一化</span></span><br><span class="line">            contacts[:, <span class="number">0</span>, :] = prune_and_normalize(contacts[:, <span class="number">0</span>, :])</span><br><span class="line">            contacts[:, <span class="number">1</span>, :] = prune_and_normalize(contacts[:, <span class="number">1</span>, :])</span><br><span class="line">            <span class="comment"># 将接触点与点云匹配（hard）</span></span><br><span class="line">            first_contact_pc_indexes, contact_indexes = match_contacts_with_pc(</span><br><span class="line">                contacts, scores, pc, <span class="variable language_">self</span>.contact_th, <span class="variable language_">self</span>.matching_policy)</span><br><span class="line">            <span class="comment"># 平衡正负样本</span></span><br><span class="line">            grasp_indexes = balance_grasp_indexes(scores[contact_indexes[:, <span class="number">0</span>]], <span class="variable language_">self</span>.sample_num, <span class="variable language_">self</span>.positive_ratio)</span><br><span class="line">            <span class="comment"># 返回训练数据</span></span><br><span class="line">            <span class="keyword">return</span> pc, first_contact_pc_indexes, contacts, angles, scores, contact_indexes, grasp_indexes, shape</span><br><span class="line">        <span class="comment"># 测试数据处理流程</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 使用固定的视角</span></span><br><span class="line">            camera_pose = cam_info[<span class="string">&#x27;view%d&#x27;</span> % <span class="variable language_">self</span>.view]</span><br><span class="line">            <span class="comment"># ShapeNetSem-8测试数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>.split == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">                pc = get_point_cloud_from_cam_info(<span class="variable language_">self</span>.shape_dir[shape], camera_pose, <span class="variable language_">self</span>.view)</span><br><span class="line">            <span class="comment"># YCB-8测试数据</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="variable language_">self</span>.split == <span class="string">&#x27;ycb8_test&#x27;</span>:</span><br><span class="line">                pc = np.load(osp.join(<span class="variable language_">self</span>.shape_dir[shape], <span class="string">f&#x27;pc<span class="subst">&#123;self.view&#125;</span>.npy&#x27;</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Unknown split <span class="subst">&#123;self.split&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 对点云进行修剪和归一化</span></span><br><span class="line">            pc = prune_and_normalize(pc)</span><br><span class="line">            <span class="comment"># 返回测试数据</span></span><br><span class="line">            <span class="keyword">return</span> pc, shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取抓取标注数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_grasps</span>(<span class="params">self, shape</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Read all grasps annotations related to the specific shape</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 加载接触点数据</span></span><br><span class="line">        contacts = np.load(osp.join(<span class="variable language_">self</span>.anno_root, <span class="string">&#x27;candidate&#x27;</span>, shape + <span class="string">&#x27;_contact.npy&#x27;</span>))</span><br><span class="line">        <span class="comment"># 加载角度数据</span></span><br><span class="line">        angles = np.load(osp.join(<span class="variable language_">self</span>.anno_root, <span class="string">&#x27;candidate&#x27;</span>, shape + <span class="string">&#x27;_cos.npy&#x27;</span>))</span><br><span class="line">        <span class="comment"># 加载标签数据(0/1表示抓取成功/失败)</span></span><br><span class="line">        labels = np.load(osp.join(<span class="variable language_">self</span>.anno_root, <span class="string">&#x27;simulateResult&#x27;</span>, shape + <span class="string">&#x27;.npy&#x27;</span>))</span><br><span class="line">        <span class="comment"># 确保数据一致性</span></span><br><span class="line">        <span class="keyword">assert</span> labels.shape[<span class="number">0</span>] == contacts.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 样本采样(训练时使用)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.sample_num <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 获取正样本索引（标签为1）</span></span><br><span class="line">            posi_idx = np.nonzero(labels.reshape(-<span class="number">1</span>))[<span class="number">0</span>].reshape(-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 获取负样本索引（标签为0）</span></span><br><span class="line">            nega_idx = np.nonzero((labels == <span class="literal">False</span>).reshape(-<span class="number">1</span>))[<span class="number">0</span>].reshape(-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 计算正负样本数量</span></span><br><span class="line">            posi_num = posi_idx.shape[<span class="number">0</span>]</span><br><span class="line">            nega_num = nega_idx.shape[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 计算总采样数量</span></span><br><span class="line">            tot_sample_num = <span class="variable language_">self</span>.tot_num</span><br><span class="line">            <span class="comment"># 计算期望的正负样本数量</span></span><br><span class="line">            posi_exp = tot_sample_num // <span class="number">2</span></span><br><span class="line">            nega_exp = tot_sample_num - posi_exp</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 正样本采样（期望值小则随机选择期望值个数，大则从采样中重复相差的个数）</span></span><br><span class="line">            <span class="keyword">if</span> posi_num &gt; posi_exp:</span><br><span class="line">                posi_idx = np.random.choice(posi_idx, posi_exp, replace=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                posi_idx = np.concatenate((posi_idx, np.random.choice(posi_idx, posi_exp - posi_num, replace=<span class="literal">True</span>)),</span><br><span class="line">                                          axis=<span class="literal">None</span>)</span><br><span class="line">            <span class="comment"># 负样本采样</span></span><br><span class="line">            <span class="keyword">if</span> nega_num &gt; nega_exp:</span><br><span class="line">                nega_idx = np.random.choice(nega_idx, nega_exp, replace=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nega_idx = np.concatenate((nega_idx, np.random.choice(nega_idx, nega_exp - nega_num, replace=<span class="literal">True</span>)),</span><br><span class="line">                                          axis=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 合并并打乱所有样本索引</span></span><br><span class="line">            all_idx = np.concatenate([posi_idx, nega_idx], <span class="number">0</span>)</span><br><span class="line">            np.random.shuffle(all_idx)</span><br><span class="line">            <span class="comment"># 根据采样结果更新数据</span></span><br><span class="line">            labels = labels[all_idx]</span><br><span class="line">            contacts = contacts[all_idx]</span><br><span class="line">            angles = angles[all_idx]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载相机信息</span></span><br><span class="line">        cam_info_path = osp.join(<span class="variable language_">self</span>.img_root, shape, <span class="string">&#x27;CameraInfo.npy&#x27;</span>)</span><br><span class="line">        cam_info = read_camera_info(cam_info_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保数据一致性</span></span><br><span class="line">        <span class="keyword">assert</span> (contacts.shape[<span class="number">0</span>] == angles.shape[<span class="number">0</span>] <span class="keyword">and</span> contacts.shape[<span class="number">0</span>] == angles.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 返回相机信息、接触点、角度和标签</span></span><br><span class="line">        <span class="keyword">return</span> cam_info, contacts, angles, labels</span><br></pre></td></tr></table></figure>
<h2 id="YCB76-Data">YCB76_Data</h2>
<p>只用于测试集，固定相机视角</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">YCB76_Data</span>(data.Dataset):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_root, split=<span class="string">&quot;test&quot;</span>, view=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        YCB-76测试数据集加载类 - 仅用于仿真测试，不包含抓取标注数据</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            data_root: 数据集根目录路径(包含test_set.csv文件)</span></span><br><span class="line"><span class="string">            split: 数据集划分(仅支持test模式)</span></span><br><span class="line"><span class="string">            view: 使用的视角编号(0-9)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 参数校验</span></span><br><span class="line">        <span class="keyword">assert</span> split == <span class="string">&quot;test&quot;</span>, <span class="string">f&quot;YCB_76_Data - only test split available.&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt;= view &lt;= <span class="number">9</span>, <span class="string">f&quot;YCB_76_Data - only views 0 to 9 available.&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化类属性</span></span><br><span class="line">        <span class="variable language_">self</span>.data_root = data_root  <span class="comment"># 数据集根目录</span></span><br><span class="line">        <span class="variable language_">self</span>.split = split          <span class="comment"># 数据集划分模式</span></span><br><span class="line">        <span class="variable language_">self</span>.view = view           <span class="comment"># 当前使用的视角编号</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;YCB76_Data - data_root: <span class="subst">&#123;self.data_root&#125;</span>, split: <span class="subst">&#123;self.split&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 读取数据集划分文件</span></span><br><span class="line">        file_path = osp.join(<span class="variable language_">self</span>.data_root, <span class="string">&quot;%s_set.csv&quot;</span> % <span class="variable language_">self</span>.split)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            lines = file.readlines()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取所有物体名称列表</span></span><br><span class="line">        <span class="variable language_">self</span>.shapes = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置点云数据目录</span></span><br><span class="line">        <span class="variable language_">self</span>.pc_dir = osp.join(data_root, <span class="string">&#x27;point_clouds&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取数据集中物体数量</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            物体数量(int)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.shapes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取单个样本数据</span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            index: 样本索引</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            pc: 点云数据(已缩放)</span></span><br><span class="line"><span class="string">            shape: 物体名称</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获取指定索引的物体名称</span></span><br><span class="line">        shape = <span class="variable language_">self</span>.shapes[index]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建点云文件路径并加载</span></span><br><span class="line">        pc_fn = osp.join(<span class="variable language_">self</span>.pc_dir, shape, <span class="string">f&#x27;pc<span class="subst">&#123;self.view&#125;</span>.npy&#x27;</span>)</span><br><span class="line">        pc = np.load(pc_fn)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注释掉的归一化处理(可能对大物体裁剪过多)</span></span><br><span class="line">        <span class="comment"># pc = prune_and_normalize(pc)  </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对点云数据进行缩放处理</span></span><br><span class="line">        pc = pc / np.array([<span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span> / <span class="number">2</span>, <span class="number">0.22</span>])  <span class="comment"># 使用固定比例缩放</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pc, shape</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">小乐</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小乐</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
